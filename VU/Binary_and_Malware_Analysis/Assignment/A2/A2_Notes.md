# How to Manually Unpack a Binary
https://medium.com/@0x8080/how-to-manually-unpack-a-binary-e56e18732b3b

>[!warning] It describes also
>how to completely investigating a syscall



- Runna in gdb
- setta un `catch syscall mmap`
- runna
- `i r rax` -->  per vedere che indirizzo ritorna `mmap`
- `watch -l * ((char *) 0x400000)` -->  per settare un hardware breakpoint
	- in questo modo breakka quando all'indirizzo `0x400000` viene scritto qualcosa
	  (visto che per ora è tutto zero)
	- continua -->  `c`
	- l'indirizzo a cui arrivi è il punto in cui viene scritto qualcosa all'interno dell'indirizzo di ritorno di mmap (=> probabilmente sta unpackando il binario qui)![[Pasted image 20240413141117.png]]
	  l'indirizzo è `0x101fd8`

## Dump binary
In ghidra:
`load_second_stage`
`launch_second_stage`

Dump binary:
`b *0x0010013d`
`r`
`vmap` (simile a info proc mapping)
`x/100xg 0x0000000000400000`
questo è l'ELF header
![[Pasted image 20240413151602.png|400]]
=>
`dump memory binary.elf 0x0000000000400000 0x0000000000506000`
Contiene i program headers ma non i section headers
=>
ora bisogna solo patchare l'ELF header
=>
1) scrivi un programma che chiama una funzione che usa puts
2) strippalo con https://github.com/BR903/ELFkickers 
3) caricalo con https://ide.kaitai.io/ per confrontarlo con il binario dumpato
4) Patcha con XelfViewer

## Correct Headers

1)

```
#include <stdio.h>
void print();

int main() {
	print();
	return 0;
}

void print() {
	puts("test");
}
```

2)
Per ELFkickers:
`git clone https://github.com/BR903/ELFkickers && cd ELFkickers`
`make`
`cd sstrip`
`sudo cp sstrip /usr/local/bin/`
=>
`sstrip ~/Documents/Code/comparisonBin`

3)
Confronta byte per byte con il programma che hai creato (le uniche cose che differiscono sono gli offset)
=>
https://en.wikipedia.org/wiki/Executable_and_Linkable_Format -->   per capire a cosa servono  
                                                         questi bytes
Correzioni:
- Al posto di Little Endian c'era Big Endian =>  patcha con XeldViewer `01` al posto di `02`
- machine: `X86_64` al posto di `X86`
- section Header deve essere `0` -->  perchè per caricare il binario serve solo il program header (visto che è opzionale il section header)
-  number of entries in the section header table (`qtySectionHeader`) deve essere `0` 
-  index of the section header table entry that contains the section names
    (`sectionNameIdx`) deve essere `0`
- Devono combaciare p_offset con p_vaddr![[Pasted image 20240413170425.png]]



`YYHJQYMLBSXWAUMVHNUE`

![[Pasted image 20240414175022.png|500]]

Questo while checka il valore di `DAT_00205110`
Se è diverso da 


impostare gdb sugli stessi indirizzi:
- apri gdb 
- r
- ctrl + c
- vmmap
- copia questo (che è l'inizio della mia zona con codice)![[Pasted image 20240414180729.png]]
- vai su ghidra
- clicca sull'icona verde della memoria > clicca sull'icona della casa > incolla il valore
- a questo punto matchi gli address tra ghidra e gdb


controllare qual è il valore di ritorno corretto di getauxval:
- apri VUVianConnector originale con gdb:
  `VUNIVERSE_KEY="BYJFRXXIQBNQPHPVKNHN" gdb ./VUVianConnector`
- `r`
- Ctrl+C ("esce dall'esecuzione del binario e ritorna su gdb")
- dobbiamo vedere il valore di ritorno della chiamata a `getauxval`
	- in questo modo possiamo vedere qual è il valore corretto che dovrebbe avere
	- visto che stiamo debuggando usando il binario intero (che fa l'unpack)
	- noi però la funzione `getauxval` l'abbiamo trovata solo nell'inner binary
	- quindi gli indirizzi su gdb non corrisponderanno a quelli che abbiamo su ghidra con l'inner binary
	- quindi non possiamo settare un breakpoint alla CALL a `getauxval`
	  =>
	- come impostare correttamente il breakpoint
		- `vmmap`![[Pasted image 20240415101645.png]]
		  =>
		  La zona con i dati nel binario iniziale inizia a `0x...401000`
		- Dobbiamo sommare questo indirizzo all'indirizzo corrispondente alla CALL per `getauxval` (nell'inner binary ovviamente)![[Pasted image 20240415101850.png]]
		  =>
		- verifichiamo che sia corretto stampando i byte che ci sarebbero in questo nuovo indirizzo calcolato dalla somma di `0x...401000` con CALL a `getauxval`
		- `x/4b (0x0000000000401000+0x4b2)`![[Pasted image 20240415102103.png]]
		  =>
		  _<span style="color:#00b050">sono gli stessi che ci sono di fianco alla chiamata a getauxval su ghidra</span>_
		  =>
		  siamo all'indirizzo corretto
		  =>
		- `b *(0x0000000000401000+0x4b2)`   (settiamo un breakpoint a questo indirizzo)
		- `c`
		- ora dobbiamo fare il login in VUVian (metti la password e connettiti con `l`)
		- `si`   (per entrare nella chiamata)
		- `fin` (per titornare dalla chiamata)
		- `RAX` a questo punto conterrà il valore corretto ritornato da `getauxval`![[Pasted image 20240415102425.png]]
		  Questo è il valore -->  `0x99840d1fcba1e780`
		- Ora dobbiamo inserire questo 


- `0x336537140c6b0f20`  
- Nega questo ultimo valore e fai l'and logico con quello nell'immagine![[Pasted image 20240414183549.png]]

apri in gdb l'inner binary:
- `r`
- Ctrl+C
- `b *0x5555555554b2`
- c
- inserisci la password
- 