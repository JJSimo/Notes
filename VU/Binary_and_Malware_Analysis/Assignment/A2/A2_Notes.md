# How to Manually Unpack a Binary
https://medium.com/@0x8080/how-to-manually-unpack-a-binary-e56e18732b3b

>[!warning] It describes also
>how to completely investigating a syscall



- Runna in gdb
- setta un `catch syscall mmap`
- runna
- `i r rax` -->  per vedere che indirizzo ritorna `mmap`
- `watch -l * ((char *) 0x400000)` -->  per settare un hardware breakpoint
	- in questo modo breakka quando all'indirizzo `0x400000` viene scritto qualcosa
	  (visto che per ora è tutto zero)
	- continua -->  `c`
	- l'indirizzo a cui arrivi è il punto in cui viene scritto qualcosa all'interno dell'indirizzo di ritorno di mmap (=> probabilmente sta unpackando il binario qui)![[Pasted image 20240413141117.png]]
	  l'indirizzo è `0x101fd8`

## Dump binary
In ghidra:
`load_second_stage`
`launch_second_stage`

Dump binary:
`b *0x0010013d`
`r`
`vmap` (simile a info proc mapping)
`x/100xg 0x0000000000400000`
questo è l'ELF header
![[Pasted image 20240413151602.png|400]]
=>
`dump memory binary.elf 0x0000000000400000 0x0000000000506000`
Contiene i program headers ma non i section headers
=>
ora bisogna solo patchare l'ELF header
=>
1) scrivi un programma che chiama una funzione che usa puts
2) strippalo con https://github.com/BR903/ELFkickers 
3) caricalo con https://ide.kaitai.io/ per confrontarlo con il binario dumpato
4) Patcha con XelfViewer

## Correct Headers

1)

```
#include <stdio.h>
void print();

int main() {
	print();
	return 0;
}

void print() {
	puts("test");
}
```

2)
Per ELFkickers:
`git clone https://github.com/BR903/ELFkickers && cd ELFkickers`
`make`
`cd sstrip`
`sudo cp sstrip /usr/local/bin/`
=>
`sstrip ~/Documents/Code/comparisonBin`

3)
Confronta byte per byte con il programma che hai creato (le uniche cose che differiscono sono gli offset)
=>
https://en.wikipedia.org/wiki/Executable_and_Linkable_Format -->   per capire a cosa servono  
                                                         questi bytes
Correzioni:
- Al posto di Little Endian c'era Big Endian =>  patcha con XeldViewer `01` al posto di `02`
- machine: `X86_64` al posto di `X86`
- section Header deve essere `0` -->  perchè per caricare il binario serve solo il program header (visto che è opzionale il section header)
-  number of entries in the section header table (`qtySectionHeader`) deve essere `0` 
-  index of the section header table entry that contains the section names
    (`sectionNameIdx`) deve essere `0`
- Devono combaciare p_offset con p_vaddr![[Pasted image 20240413170425.png]]



`YYHJQYMLBSXWAUMVHNUE`

![[Pasted image 20240414175022.png|500]]

Questo while checka il valore di `DAT_00205110`
Se è diverso da 


impostare gdb sugli stessi indirizzi:
- apri gdb 
- r
- ctrl + c
- vmmap
- copia questo (che è l'inizio della mia zona con codice)![[Pasted image 20240414180729.png]]
- vai su ghidra
- clicca sull'icona verde della memoria > clicca sull'icona della casa > incolla il valore
- a questo punto matchi gli address tra ghidra e gdb


controllare qual è il valore di ritorno corretto di getauxval:
- apri VUVianConnector originale con gdb
  VUNIVERSE_KEY="BYJFRXXIQBNQPHPVKNHN" gdb ./VUVianConnector

- `0x99840d1fcba1e780`
- `0x336537140c6b0f20`  
- Nega questo ultimo valore e fai l'and logico con quello nell'immagine![[Pasted image 20240414183549.png]]
