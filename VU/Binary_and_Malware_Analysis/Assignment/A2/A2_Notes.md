# How to Manually Unpack a Binary
https://medium.com/@0x8080/how-to-manually-unpack-a-binary-e56e18732b3b

>[!warning] It describes also
>how to completely investigating a syscall



- Runna in gdb
- setta un `catch syscall mmap`
- runna
- `i r rax` -->  per vedere che indirizzo ritorna `mmap`
- `watch -l * ((char *) 0x400000)` -->  per settare un hardware breakpoint
	- in questo modo breakka quando all'indirizzo `0x400000` viene scritto qualcosa
	  (visto che per ora è tutto zero)
	- continua -->  `c`
	- l'indirizzo a cui arrivi è il punto in cui viene scritto qualcosa all'interno dell'indirizzo di ritorno di mmap (=> probabilmente sta unpackando il binario qui)![[Pasted image 20240413141117.png]]
	  l'indirizzo è `0x101fd8`
In ghidra:
`load_second_stage`
`launch_second_stage`

Dump binary:
`b *0x0010013d`
`r`
`vmap` (simile a info proc mapping)
`x/100xg 0x0000000000400000`
questo è l'ELF header
![[Pasted image 20240413151602.png|400]]
=>
`dump memory binary.elf 0x0000000000400000 0x0000000000506000`
Contiene i program headers ma non i section headers
=>
ora bisogna solo patchare l'ELF header
=>
1) scrivi un programma che chiama una funzione che usa puts
2) strippalo con https://github.com/BR903/ELFkickers 
3) caricalo con https://ide.kaitai.io/ per confrontarlo con il binario dumpato

1)

```
#include <stdio.h>
void print();

int main() {
	print();
	return 0;
}

void print() {
	puts("test");
}
```

Per ELFkickers:
`git clone https://github.com/BR903/ELFkickers && cd ELFkickers`
`make`
`cd sstrip`
`sudo cp sstrip /usr/local/bin/`
=>
`sstrip ~/Documents/Code/comparisonBin`

