# Run the script
To run the script use -->  `./unpack.sh`

It will automatically use the `dump_and_patch.py` and the `ld_preload_getauxval.c` programs
 

# Dump the inner binary
The main entry point inside a binary is usually the dynamic linker. If we use `strace` with a simple binary (example `/bin/true`) we can see that the calls that are made when the dynamic linker is called are in a pretty unique order: before the dynamic linker we have the `execv` call that allocates memories for the user space exec and then `brk(NULL)` and `arch_prctl()`.

Inside our binary, we can find these 2 calls, and before them there are a bunch of `mmap` calls, that are used probably to reimplement the `execv` call, so to allocate memory for the inner binary.
We can find 4 `mmap` calls, that are a default sections number in an ELF binary. These `mmap` calls are used with the `MAP_ANONYMOUS` flag, so the outer binary is allocating 4 sections and it's initializing them to 0.
After these calls, there are other 4 `mmap` calls followed by the `brk(NULL)` and `arch_prctl()`: therefore, here the outer binary is copying the inner binary inside these regions. 
To confirm that, we can set a watchpoint to the address returned by the first `mmap` call 
(`0x400000`): in this way the binary will stop when the first byte is overwritten at the address returned by `mmap`.
The written value is `7f` and if we repeat the same process for the next 3 bytes we'll have the ELF magic bytes. With this process I understood that the program header of the inner binary starts at `0x400000`.

To understand since which address I needed to dump and also at what point in the execution, I went through gdb to the 8th `mmap` call and I saw that I was still in the `setup_main()` function. 
Using the `vmmap` command inside gdb, I could see all the regions allocated with the `mmap` calls. The last one ends at `0x506000`, so probably the inner binary starts from `0x400000` to `0x506000`.
To be sure to dump the inner binary once it has been fully loaded into memory, I looked in ghidra at the function that called the `setup_main()` , and I saw that after returning from `setup_main()` Ghidra couldn't recover the jump table. So I tried to make a breakpoint into the instruction next to the  `setup_main()` call, and in this way I could dump the entire inner binary.

# Patch the inner binary
After having dumped the inner binary I tried to run it but I got a segmentation fault. Using tools such as `readelf`, `file` and `xxd` I realized that the ELF header was not correct. 
To completely understand what the problems were, I compared byte per byte the inner binary with a simple C binary. 
The first byte that I patched was the endianness one, which was set to Big Endian instead of Little Endian (so I patched it with `0x01`).
Then I fixed the Machine type field, since it wasn't X86_64 (so I patched it to `0x3E`).

Since the inner binary was dumped from memory, the program offsets must be the same as those of the virtual program.
In 3 of them the addresses were not equal, so I patched them as well 
(all three had to be `0x4dc0` to be the same as the virtual offsets).

After these changes, by using `readelf` and `file` everything seemed correct and I was able to run the inner binary and connect to the VUVianConnector.

# Find the password
If you run the inner binary and try to set a random password it will be display the message "Invalid password; aborting". I then found inside ghidra this string and looking at its references I found a function that performs a password comparison similar to the one found in previous assignment.
For each password character entered, the function checks whether it is different from or equal to a given character.
Concatenating all these single characters I found this password: `YYHJQYMLBSXWAUMVHNUE`

# Explanation of the anti-unpacking techniques
By entering the password directly into the inner binary and trying to connect to VUVian, the program says that the password is correct but fails to login and prints an endless loop of ".", while by entering the password into the original binary (with the various patches of the first assignment) it succeeds in login and connecting to VUVian.
Also when you run the inner binary and/or insert the password you will have a printed message that says: 
`WARNING:	Invalid environment; connection ID potentially uncomputable!`

I started analyzing the main code in Ghidra and realized that both the warning message that is displayed and the infinite loop of printed dots depends on the return value of the call to `getauxval(8)`.  
The `getauxval()` is a function that allows to obtain additional values (called auxiliary vectors) on the execution environment of the process. So the function takes as an argument a specific value that identifies the type of auxiliary information you want to retrieve and returns the corresponding value.
We can say that the code in the binary first checks whether you are running the binary from the external binary or not by calling `getauxval(8)` the first time, and if the returned value is wrong it prints the warning message. Next, when a login is attempted, `getauxval(8)` is called and its returning value is checked within a `while` loop if the value returned by getauxval is correct: if it is not, an endless loop of points is printed.

## Find the correct getauxval returning value
Since in the outer binary the login works and also you don't have the warning message, therefore `getauxval(8)` should return the correct value. For this reason I opened the outer binary in gdb and I setted a breakpoint to the first `getauxval(8)` call  (I had to adjust the addresses, since the outer binary couldn't access to an address inside the inner binary).
By doing that I could find the correct `getauxval(8)` returning value inside the `rax` register: `0x99840d1fcba1e780`.
To check whether this was the right thing to look at, I opened the inner binary in gdb, I setted breakpoints to the 2 `getaxuval(8)` call and after each of them I patched the value of `rax` content with the correct value. 

# Anti Fixing
According to the slides, to fix the anti-unpacking technique I didn't patch directly the binary.
Instead I created a C program that reimplemented the `getauxval()` function using the `LD_PRELOAD` environment variable.
This environment variable is used to specify a shared library that is to be loaded first by the loader. Loading this shared library it allows to intercept `getauxval()` function calls and using the dynamic loader API I can bind the originally intended function to a completely different function.

My `getauxval()` function simply checks if the parameter that is passed through the original `getauxval()` is 8, and if so it will return the correct value that the inner binary expected. 

I then compiled the C program in this way: 
`gcc ld_preload_getauxval.c -o ld_preload_getauxval.so -fPIC -shared -ldl -D_GNU_SOURCE`

And by running the inner binary also passing the environment variable `LD_PRELOAD`, I was able to correct the anti-unpacking technique and make the inner binary thinks it was executed by the outer binary (so I was able to login and connect to the VUVian AI).
`LD_PRELOAD=./ld_preload_getauxval.so ./VUVianConnector.unpacked`

# Automate everything
## unpack.sh
The main script is the `unpack.sh` bash script, that first executes the `dump_and_patch.py` python script, then compiled my version of the `getaxuval` function and finally executes the inner binary by passing the `LD_PRELOAD` environment variable.

## dump_and_patch.py
It basically performs 3 steps:
1) 
	- It launches gdb as a subprocess to set a breakpoint at a specified address in the outer binary file
	- executes the program until the breakpoint is hit
	- dumps the memory range between specified start and end addresses into an output file
	   
2) It opens the dumped binary file in binary write mode and patches specific byte offsets with new values
3) It sets the executable permission on the patched binary file

## ld_preload_getauxval.c






