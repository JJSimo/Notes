# Dump the inner binary
The main entry point inside a binary is usually the dynamic linker. If we use `strace` with a simple binary (example `/bin/true`) we can see that the calls that are made when the dynamic linker is called are in a pretty unique order: before the dynamic linker we have the `execv` call that allocates memories for the user space exec and then `brk(NULL)` and `arch_prctl()`.

Inside our binary, we can find these 2 calls, and before them there are a bunch of `mmap` calls, that are used probably to reimplement the `execv` call, so to allocate memory for the inner binary.
We can find 4 `mmap` calls, that are a default sections number in an ELF binary. These `mmap` calls are used with the `MAP_ANONYMOUS` flag, so the outer binary is allocating 4 sections and it's initializing them to 0.
After these calls, there are other 4 `mmap` calls followed by the `brk(NULL)` and `arch_prctl()`: therefore, here the outer binary is copying the inner binary inside these regions. 
To confirm that, we can set a watchpoint to the address returned by the first `mmap` call 
(`0x400000`): in this way the binary will stop when the first byte is overwritten at the address returned by `mmap`.
The written value is `7f` and if we repeat the same process for the next 3 bytes we'll have the ELF magic bytes. With this process I understood that the program header of the inner binary starts at `0x400000`.

To understand since which address I needed to dump and also at what point in the execution, I went through gdb to the 8th `mmap` call and I saw that I was still in the `setup_main()` function. 
Using the `vmmap` command inside gdb, I could see all the regions allocated with the `mmap` calls. The last one ends at `0x506000`, so probably the inner binary starts from `0x400000` to `0x506000`.
To be sure to dump the inner binary once it has been fully loaded into memory, I looked in ghidra at the function that called the `setup_main()` , and I saw that after returning from `setup_main()` Ghidra couldn't recover the jump table. So I tried to make a breakpoint into the instruction next to the  `setup_main()` call, and in this way I could dump the entire inner binary.

# Patch the inner binary
After having dumped the inner binary I tried to run it but I got a segmentation fault. Using tools such as `readelf`, `file` and `xxd` I realized that the ELF header was not correct. 
To completely understand what the problems were, I compared byte per byte the inner binary with a simple C binary. 
The first byte that I patched was the endianness one, which was set to Big Endian instead of Little Endian (so I patched it with `0x01`).
I also fixed these fields inside the header:
- the Machine type field wasn't X86_64 (so I patched it to `0x3E`)
- the ProgramHeaderOffset should be 0, so set to unused (so I patched it to `0x00`)
- the number of entries in the section header table must be 0 (so I patched it to `0x00`)
- the index of the section header table entry that contains the section names must be `0`
  (so I patched it to `0x00`)

Since the inner binary was dumped from memory, the program offsets must be the same as those of the virtual program.
In 3 of them the addresses were not equal, so I patched them as well 
(all three had to be `0x4dc0` to be the same as the virtual offsets).

After these changes, by using `readelf` and `file` everything seemed correct and I was able to run the inner binary and connect to the VUVianConnector.

# Find the password
If you run the inner binary and try to set a random password it will be display the message "Invalid password; aborting". I then found inside ghidra this string and looking at its references I found a function that performs a password comparison similar to the one found in previous assignment.
For each password character entered, the function checks whether it is different from or equal to a given character.
Concatenating all these single characters I found this password: `YYHJQYMLBSXWAUMVHNUE`

By entering the password directly into the inner binary and trying to connect to VUVian, the program says that the password is correct but fails to login, while by entering the password into the original binary (with the various patches of the first assignment) it succeeds in login and connecting to VUVian.





need it for static linking,
