# Find/explain conditions for syntactic/semantic validity
## Find syntactic
dall'`entry` , c'è `glibc` che come primo parametro passa la funzione `main`
Nella funzione `main`:
![[Pasted image 20240522133832.png|600]]
- `uVar2` viene calcolato usando una funzione
- in base al valore di questa variabile vengono stampati i messaggi Input sequence correct oppure Error
  =>
- la funzione in questione checka la syntactic e la semantic 
  (l'ho chiamata `check_synt_sem`)

La funzione `check_synt_sem`:
accetta due parametri, `param_1` e `param_2`, entrambi puntatori a caratteri (`char*`). 
- verificare la sintassi e la semantica di una stringa e 
- la converte in una rappresentazione esadecimale
- memorizza il risultato in `param_1`
=>
- ogni Ch in `param_2` viene confrontato con i Ch in `DAT_00107040` 
  (rinominata `possible_characters`)![[Pasted image 20240522134611.png]]

- se il Ch:
	- non è trovato nella sequenza entro 32 iterazioni => si esce dal ciclo
	-  viene trovato => il suo indice viene utilizzato per creare una sequenza codificata
		- la codifica dei caratteri trovati viene memorizzata in `local_78`
		- Si continua fino a che non sono stati processati più di **16 Ch** o la stringa termina
![[Pasted image 20240522140412.png]]
Nell'immagine:
- si controlla se il carattere in `pcVar6` è tra quelli consentiti => se si esce dal ciclo while
- controlla al massimo 32 volte, dopo di che va alla label `LAB_00102628`

poi:
- `uVar3` viene impostato al valore di `lVar4`
- `pcVar6` viene incrementato per passare al carattere successivo di `param_2`
- Il bit meno significativo di `lVar4` viene memorizzato come un byte nel successivo elemento di `local_78` (==che è l'array che contiene la codifica della stringa==)

qui viene fatta la codifica:
![[Pasted image 20240522141346.png]]
`(uVar3 & 0x1fe) << 7`:
- `uVar3 & 0x1fe` -->  estrae i bit 1-8 di `uVar3` e imposta il bit meno significativo a 0
- `<< 7` -->  shifta il risultato di 7 posizioni (porta i bit 1-8 ai bit 8-15, con il bit 0 ancora a 0)

`(int)uVar3 >> 2 & 0xffU`:
- `(int)uVar3 >> 2` -->  shifta `uVar3` di 2 bit (perdendo i due bit meno significativi)
- `& 0xffU` --> maschera il risultato per mantenere solo gli 8 bit meno significativi

`( ((uVar3 & 0x1fe) << 7 | (int)uVar3 >> 2 & 0xffU)    << 8)`
- combina poi i risultati di questi 2 operqaioni con un -->  `OR` bit a bit 
- shifta a sx di 8 posizioni (spostando il risultato nei bit 8-23)

`(int)uVar3 >> 3 & 0xffU`
simile a passo 2 ma shifti di 3 bit e poi mantieni solo gli 8 bit meno significativi

`(((uVar3 & 0x1fe) << 7 | (int)uVar3 >> 2 & 0xffU) << 8          | 
`(int)uVar3 >> 3 & 0xffU)                                              << 8`
- combina il risultato dell'ultimo passo con il risultato dell'`OR` precedente
- shifta a sinistra di 8 posizioni, spostando tutto nei bit 16-31

`(int)uVar3 >> 4 & 0xffU`
simile a passo 2 ma shifti di 4 bit

`(((uVar3 & 0x1fe) << 7 | (int)uVar3 >> 2 & 0xffU) << 8 | (int)uVar3 >> 3 & 0xffU) << 8 | (int)uVar3 >> 4 & 0xffU)`
combina tutti i risultati intermedi con `OR`

`& 0x1010101`
- mantiene solo i bit 0, 8, 16, e 24 del risultato combinato
  (questo mascheramento finale seleziona specifici bit del risultato finale)
