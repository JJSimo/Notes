# Find/explain conditions for syntactic/semantic validity
## Find syntactic
dall'`entry` , c'è `glibc` che come primo parametro passa la funzione `main`
Nella funzione `main`:
![[Pasted image 20240522133832.png|600]]
- `uVar2` viene calcolato usando una funzione
- in base al valore di questa variabile vengono stampati i messaggi Input sequence correct oppure Error
  =>
- la funzione in questione checka la syntactic e la semantic 
  (l'ho chiamata `check_synt_sem`)

La funzione `check_synt_sem`:
accetta due parametri, `param_1` e `param_2`, entrambi puntatori a caratteri (`char*`). 
- verificare la sintassi e la semantica di una stringa e 
- la converte in una rappresentazione esadecimale
- memorizza il risultato in `param_1`
=>
- ogni Ch in `param_2` viene confrontato con i Ch in `DAT_00107040` 
  (rinominata `possible_characters`)![[Pasted image 20240522134611.png]]

## Encoding
- se il Ch:
	- non è trovato nella sequenza entro 32 iterazioni => si esce dal ciclo
	-  viene trovato => il suo indice viene utilizzato per creare una sequenza codificata
		- la codifica dei caratteri trovati viene memorizzata in `local_78`
		- Si continua fino a che non sono stati processati più di **16 Ch** o la stringa termina
![[Pasted image 20240522150435.png]]
Nell'immagine:
- si controlla se il carattere in `pcVar6` è tra quelli consentiti => se si esce dal ciclo while
- controlla al massimo 32 volte, dopo di che va alla label `LAB_00102628`

poi:
- `uVar3` viene impostato al valore di `lVar4`
- `pcVar6` viene incrementato per passare al carattere successivo di `param_2`
- Il bit meno significativo di `lVar4` viene memorizzato come un byte nel successivo elemento di `local_78` (==che è l'array che contiene la codifica della stringa==)

Qui viene fatta la codifica:
![[Pasted image 20240522141346.png]]

## Decoding
Qui viene fatta la decodifica:![[Pasted image 20240523100128.png|600]]

La decodifica viene fatta se:
- `bVar1` è 0
- il valore di `bVar1` è assegnato dall'output di `FUN_00102780`
  =>
  probabilmente `FUN_00102780` è il metodo che checka la semantica

La decodifica:
converte una sequenza di bit in una stringa esadecimale

1. Inizializza una stringa contenente i caratteri esadecimali `"0123456789abcdef"` §
   (che verranno utilizzati per rappresentare i valori esadecimali)
2. Itera attraverso la sequenza di bit, prendendo 8 bit alla volta.
3. Per ogni gruppo di 8 bit, converte questa sequenza di bit in un numero intero usando l'operatore `<<` per spostare i bit in posizione corretta e l'operatore `|` per combinare i bit.
4. Utilizza il valore numerico ottenuto per ottenere il carattere esadecimale corrispondente dalla stringa dei caratteri esadecimali e lo aggiunge all'output.
5. Alla fine, restituisce la stringa esadecimale formata dai caratteri corrispondenti ai valori esadecimali rappresentati dalla sequenza di bit.

## Check semantic
`FUN_00102780:`
1. La funzione prende una sequenza di bit in input, divisa in blocchi di 8 bit ciascuno.
2. Per ogni blocco di 8 bit, controlla la presenza o l'assenza di bit specifici in determinate posizioni.
3. Se un certo bit è presente in una posizione specifica, aggiunge un valore numerico corrispondente a una variabile di accumulo.
4. Alla fine, restituisce il valore accumulato, che rappresenta una sorta di "punteggio" basato sulle caratteristiche della sequenza di bit.


parti da blank
`8*80`
checka se == 0 o == 1
