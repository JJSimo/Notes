# Find and explain conditions for syntactic/semantic validity and IR conversion 
By analyzing the binary in Ghidra, within the `main` function I found the function that performs all the checks for the syntactic and semantic validation, since its return value is assigned to a variable and by checking its value the binary returns a string such as:
- Invalid input sequence
- Input sequence ... maps to:  ...
- Input sequence has no mapping

I called the function that does all these checks `check_synt_sem`.
The `check_synt_sem` function takes 2 parameters,  the second one, `param_2` contains the string that you pass to the binary as input string.
## Check syntactic
This function first checks for each characters inside `param_2` if it's not equal to one of the characters within a string stored in memory. To this string is concatenated as the first value `@`.
So here the function is checking the syntactic of the string that we gave as input to the binary, thus all the possible characters are:
`@A1C2E4H5K6M7P8R9UVWXYZ*~^&/:,;-`  (I called this string `possible_chars`)
![[Pasted image 20240525124510.png|650]]
If a character inside the input string is not equal to one of the characters with `possible_chars`, the function also increments an index

The last instruction in the outer `while` loop, that is the loop that checks if the input string is terminated, checks if the index size. So one other syntactic check is that the input string must be 16 characters long.

After the inner while loop, the function performs the actual encoding.
![[Pasted image 20240525132331.png|600]]

## Encoding
The encoding technique for each of the 16 characters, maps the index of the found character to binary, representing the value in 5 bits and then saves this representation.
So for example, if we pass to the binary this string: 
`@A1C2E4H5K6M7P8R` (that are the first 16 characters in the `possible_chars` string).
The IR should be like this:
![[Pasted image 20240525133044.png|180]]
Each 5 bits represent the index in the `possible_chars` string of the corresponding character present in the input string.
To get this output, I wrote a program in python that takes a string as input and converts it into a sequence of bits. For each character in the string, it finds its index in a predefined character map and then converts this index to a 5-bit binary representation

## Check semantic
After checking that the input string has 16 characters, the `check_synt_sem` function call another function, that I renamed `check_IR_has_semantic`, that controls if the IR has a semantic, so its checks the semantic.
![[Pasted image 20240525173827.png]]
The function loops through the string in blocks of 8 characters. For each block of 8 characters, it determines which bits are nonzero and calculates an integer value based on that. This value is then combined with another value, `uVar2`, by an XOR operation, and the result is added to the `param_2` parameter.
Finally, the function returns the resulting value of `param_2` after the completion of the loop.
If the return value is `0`, the main function computes the output of the IR in the next method and then it decodes the result.
![[Pasted image 20240525174943.png|620]]


## Decoding
