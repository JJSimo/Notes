# Find and explain conditions for syntactic/semantic validity and IR conversion 
By analyzing the binary in Ghidra, within the `main` function I found the function that performs all the checks for the syntactic and semantic validation, since its return value is assigned to a variable and by checking its value the binary returns a string such as:

- Invalid input sequence
- Input sequence ... maps to:  ...
- Input sequence has no mapping

I called the function that does all these checks `check_synt_sem`.
The `check_synt_sem` function takes 2 parameters,  the second one, `param_2` contains the string that you pass to the binary as input string.
## Check syntactic
This function first checks for each characters inside `param_2` if it's not equal to one of the characters within a string stored in memory. To this string is concatenated as the first value `@`.
So here the function is checking the syntactic of the string that we gave as input to the binary, thus all the possible characters are:
`@A1C2E4H5K6M7P8R9UVWXYZ*~^&/:,;-`  (I called this string `possible_chars`)
![[Pasted image 20240525124510.png|650]]
If a character inside the input string is not equal to one of the characters with `possible_chars`, the function also increments an index

The last instruction in the outer `while` loop, that is the loop that checks if the input string is terminated, checks if the index size. So one other syntactic check is that the input string must be 16 characters long.

After the inner while loop, the function performs the actual encoding.
![[Pasted image 20240525132331.png|600]]

## Encoding
The encoding technique for each of the 16 characters, maps the index of the found character to binary, representing the value in 5 bits and then saves this representation.
So for example, if we pass to the binary this string: 
`@A1C2E4H5K6M7P8R` (that are the first 16 characters in the `possible_chars` string).
The IR should be like this:
![[Pasted image 20240525133044.png|180]]
Each 5 bits represent the index in the `possible_chars` string of the corresponding character present in the input string.
To get this output, I wrote a program in python that takes a string as input and converts it into a sequence of bits. For each character in the string, it finds its index in a predefined character map and then converts this index to a 5-bit binary representation

## Check semantic
After checking that the input string has 16 characters, the `check_synt_sem` function call another function, that I renamed `check_IR_has_semantic`, that controls if the IR has a semantic, so its checks the semantic.
![[Pasted image 20240525173827.png]]
The function loops through the string in blocks of 8 characters. For each block of 8 characters, it determines which bits are nonzero and calculates an integer value based on that. This value is then combined with another value, `uVar2`, by an XOR operation, and the result is added to the `param_2` parameter.
Finally, the function returns the resulting value of `param_2` after the completion of the loop.
If the return value is `0`, the main function computes the output of the IR in the next method and then it decodes the result.
![[Pasted image 20240525174943.png|620]]


## Decoding
The decoding is done inside the `do while` loop. For each iteration of the loop, it checks whether each character in the current 8-character block is not null. If a character is not null, it sets the corresponding bit in a variable `uVar3`. Then, it converts the value of `uVar3` to a hexadecimal representation and stores the two corresponding characters in the string `param_1`.

The loop continues until `arrayPTR` reaches the memory address of the end of the array string plus 56 (representing the end of the decoded data).

At this point, I also wrote a script to implement the decoding. 
In the script I parsed the encoded string in groups of 8 bits at a time and converted them to an integer value based on the presence or absence of bits. Then I converted this integer value to two hexadecimal characters and finally concatenated all the hexadecimal characters.
If I run my script by using the IR representation of the string that I tested in the encoding script, I obtain this decoding: `00443214c74254`
![[Pasted image 20240525180222.png]]

# Capture if input has an output
To capture if input has an output I used `angr` to perform symbolic execution.
In my script I started the execution within the address before the call to the function that checks if an input string has a semantic.
Then I set the 2 parameters the `check_IR_has_semantic` needed:

- I created a bit vector of 80 values * 8 that represents the encoded string 
  (and I stored it in `RDI`)
- I stored in `RSI` the constant value used by the function to generate the output value 
  (`0x1f`)


