# Find and explain conditions for syntactic/semantic validity and IR conversion 
By analyzing the binary in Ghidra, within the `main` function I found the function that performs all the checks for the syntactic and semantic validation, since its return value is assigned to a variable and by checking its value the binary returns a string such as:

- Invalid input sequence
- Input sequence ... maps to:  ...
- Input sequence has no mapping

I called the function that does all these checks `check_synt_sem`.
The `check_synt_sem` function takes 2 parameters,  the second one, `param_2` contains the string that you pass to the binary as input string.
## Check syntactic
This function first checks for each characters inside `param_2` if it's not equal to one of the characters within a string stored in memory. To this string is concatenated as the first value `@`.
So here the function is checking the syntactic of the string that we gave as input to the binary, thus all the possible characters are:
`@A1C2E4H5K6M7P8R9UVWXYZ*~^&/:,;-`  (I called this string `possible_chars`)
![[Pasted image 20240525124510.png|650]]
If a character inside the input string is not equal to one of the characters with `possible_chars`, the function also increments an index

The last instruction in the outer `while` loop, that is the loop that checks if the input string is terminated, checks if the index size. So one other syntactic check is that the input string must be 16 characters long.

After the inner while loop, the function performs the actual encoding.
![[Pasted image 20240525132331.png|600]]

## Encoding
The encoding technique for each of the 16 characters, maps the index of the found character to binary, representing the value in 5 bits and then saves this representation.
So for example, if we pass to the binary this string: 
`@A1C2E4H5K6M7P8R` (that are the first 16 characters in the `possible_chars` string).
The IR should be this:
`00000000010001000011001000010100110001110100001001010100101101100011010111001111`
This is a more readable representation:
![[Pasted image 20240525133044.png|180]]
Each 5 bits represent the index in the `possible_chars` string of the corresponding character present in the input string.
To get this output, I wrote a program in python that takes a string as input and converts it into a sequence of bits. For each character in the string, it finds its index in a predefined character map and then converts this index to a 5-bit binary representation

## Check semantic
After checking that the input string has 16 characters, the `check_synt_sem` function call another function, that I renamed `check_IR_has_semantic`, that controls if the IR has a semantic, so its checks the semantic.
![[Pasted image 20240525173827.png]]
The function takes 2 parameters, the first one contains the input string that we pass through the binary and the second one is a constant that is used to generate the output of the function.
The function loops through the string in blocks of 8 characters. For each block of 8 characters, it determines which bits are nonzero and calculates an integer value based on that. This value is then combined with another value, `uVar2`, by an XOR operation, and the result is added to the `param_2` parameter.
Finally, the function returns the resulting value of `param_2` after the completion of the loop.
If the return value is `0`, the main function computes the output of the IR in the next method and then it decodes the result.
![[Pasted image 20240525174943.png|620]]


## Decoding
The decoding is done inside the `do while` loop. For each iteration of the loop, it checks whether each character in the current 8-character block is not null. If a character is not null, it sets the corresponding bit in a variable `uVar3`. Then, it converts the value of `uVar3` to a hexadecimal representation and stores the two corresponding characters in the string `param_1`.

The loop continues until `arrayPTR` reaches the memory address of the end of the array string plus 56 (representing the end of the decoded data).

At this point, I also wrote a script to implement the decoding. 
The decoding is done using the output of the method the calculate the mapping of the encoded string (`generate_output` in the image above).
In the script I parsed this "hypothetical mapping", that is always represented as IR, in groups of 8 bits at a time and converted them to an integer value based on the presence or lack of bits. Then I converted this integer value to two hexadecimal characters and finally concatenated all the hexadecimal characters.

# Capture if input has an output
To capture if input has an output I used `angr` to perform symbolic execution.
In my script I started the execution within the address before the call to the function that checks if an input string has a semantic.
Then I set the 2 parameters the `check_IR_has_semantic` needed:

- I created a bit vector of 80 * 8 that represents the encoded string 
-  I stored it in `RDI` a memory address that points to the encoded string
- I stored in `RSI` the constant value used by the function to generate the output value 
  (`0x1f`)

After that, I added as a constraint the fact that each byte of the encoded string  must either equal 0 or equal 1. 
Next, I defined two memory addresses representing the correct branch and the one to be avoided: the address to be found is exactly the first address within the if statement that checks whether the value returned by the `check_IR_has_semantic` function is 0, while the address to be avoided is the first one right after the end of this if statement.
Finally, I explored using these 2 addresses as `find` and `avoid`.

# Output calculation algorithm
For the step 3 I did something really similar to step 2.
The `generate_output` takes 2 parameters, the first one is the string that will contain the output (the mapping, always in term of IR that then will be decoded) and the encoded string.
So, as I did before,  I created a bit vector that represents the encoded string.
Then, I set the 2 parameters using `RDI` and `RSI`:

- `RDI` contains a memory address that points to the buffer output
- `RSI` contains a memory address that points to the encoded string 

I also created the constraint that each byte of the encoded string must either equal 0 or equal 1.
Here, we don't have an address to avoid, so for our explore we only need to set the `find` address to the address after the `CALL` to the function that generates the output.

# Get all output
In step 4 I just combined step 2 and step 3.



