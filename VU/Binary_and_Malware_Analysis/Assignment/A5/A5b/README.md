
# Adapt angr_bf’s I/O to the universe dialect
To adapt angr_bf’s I/O to the universe dialect, so that the `.` and `,` operations are self-incrementing, I modified the `simos_bf.py` file because these operations involve interaction with the operating system simulated by `simos_bf.py`.
These operations are implemented by simulated system calls, that are indeed handled by `simos_bf.py`.
So, I simply incremented the pointer after performing the corresponding I/O operations in both the 2 classes `ReadByteToPtr` and `WriteByteAtPtr` in this way:
`self.state.regs.ptr += 1`.

# Determine required input & recover 1st part of message
Then, I created an angr script to analyze the `universe.vbf` program.
I started by creating a blank state at address 0 within the project. Next, I defined a symbolic buffer of size 29 bytes, used to model incoming input through the standard input of the program. 
I then set the state input stream (that is what the program receives as input during execution) so that it is represented as a symbolic data stream, rather than as concrete data.
To do that I used:
`stdin=angr.SimFileStream(name="stdin", content=buffer)`
 I used `SimFileStream`, which simulates the file stream representing the input the program receives during execution and specifying that the content of the input stream will be initialized with the data contained in the bit vector `buffer`.
 After that, I use the `explore` method and and I set the find address to the last address before the first conditional flag operation.
 Then,, if the program finds a solution, I print the input message and the output of the program using the `eval` method to print the concrete value of my buffer and `posix.dumps(1).decode()` to extract the standard output and encode it into a string.
Finally, both the strings are written to 2 files, `input.txt` and `output.txt`.

# Support the condition flag operation
To support the CF operations I edited the `lift_bf.py` and the `arch_bf.py` files.
In the `arch_bf.py` script I just added a new register, called `cf`, to the list of the registers.
In the  `lift_bf.py` file I implemented all the CF operations.
First, I defined the new type for the condition flag.
Then, for each operation, I created a class to handle it.
For the `@` and `&` operations, I just set the `cf` register to 1 and 0 respectively.
To implement the `(` and `)` I followed the same code that handles the `[` and `]` operations. The main difference is that here, we decide to jump or not by evaluating the `cf` value.
The `CF_BracketInstruction` class follows exactly the same logic used for `[` and `]`, so it handles the matching of parentheses `(` and `)`.
It has a jump table  to keep track of the addresses of matching parentheses.
`calculate_jump` finds the jump address for an open or closed parenthesis, using the `bracket_stack` to keep track of nested parentheses.
`_build_jump_table` builds the jump table by reading program memory and matching parentheses.
`resolve_jump` resolves the jump address using the jump table.

Then, I actually implemented the two classes to handle the two operations:
`Instruction_START_CF` jumps to the corresponding closed parenthesis if the cf flag is zero, otherwise it continues with the next instruction.
`Instruction_STOP_CF` jumps to the corresponding open parenthesis if the cf flag is not zero.
Finally, I linked the open and closed parentheses together and viceversa as for the `[` and `]` instructions.




