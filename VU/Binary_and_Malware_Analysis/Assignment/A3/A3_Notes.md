Controllare se uno dei due parametri passati a `cmp` sia tainted oppure no (oppure entrambi).
Se uno dei due o entrambi sono tainted, allora stampa il valore dei 2 registri/stringhe confrontate nel cmp 

# 1
This portion of code handles different scenarios for the comparison (`CMP`) instruction in a specific architecture.
1. **First case**: If the first operand is a register and the second is an immediate:
    - A call to the `handle_CMP_instr_reg` function is inserted before the instruction.
    - The passed arguments include the register size, register number, immediate value, and a constant reference to the register.
2. **Second case**: If the second operand is a register and the first is an immediate: 
    - The same procedure as the first case is performed, but with the operands swapped.
3. **Third case**: If the first operand is memory and the second is an immediate:
    - A call to the `handle_CMP_instr_mem` function is inserted before the instruction.
    - The passed arguments include the memory width (divided by 8 to get the number of bytes), the read memory address, the immediate value, and again the read memory address.
4. **Fourth case**: If the second operand is memory and the first is an immediate:
    - The same procedure as the third case is performed, but with the operands swapped.

In general, this part of the code identifies the type of operands present in the comparison instruction and inserts calls to appropriate functions to handle those operands before executing the instruction itself.

1. **`handle_CMP_instr_reg`**:
    - This function is responsible for handling a comparison instruction (`CMP`) where one operand is a register and the other is an immediate value.
    - Parameters:
        - `size`: The size of the register in bytes.
        - `reg`: The register number.
        - `constant_value`: The immediate value.
        - `reg_value`: The value stored in the register.
    - It increments a counter (`icount`) which likely keeps track of how many comparison instructions have been encountered.
    - It checks if the tag associated with the register (`g_regTags[reg]`) is not equal to zero. If it's not zero, it prints a message indicating the comparison between the value in the register and the immediate value.
    - There's a commented-out loop that seems to iterate over each byte of the register, comparing it with the corresponding byte of the immediate value and printing the comparison. This loop is currently disabled.
2. **`handle_CMP_instr_mem`**:
    - This function handles a comparison instruction (`CMP`) where one operand is in memory.
    - Parameters:
        - `size`: The size of the memory operand in bytes.
        - `addr`: The memory address.
        - `reg`: The register number.
    - It increments a counter (`icount`) which likely keeps track of how many comparison instructions have been encountered.
    - It converts the memory address to its corresponding shadow tag using the `addrToShadow` function.
    - It checks if the tag associated with the memory address (`*shadow`) is not equal to zero. If it's not zero, it prints a message indicating the comparison between the value in memory and the value in the register specified by `reg`.
    - There's a commented-out line that seems to print a message indicating that a comparison instruction with memory has been encountered. This line is currently disabled.

In summary, both functions are responsible for printing messages indicating the comparison between values in registers or memory and immediate values, along with some additional debug information.

1. In base all'opcode dell'istruzione (addizione, sottrazione, shift, XOR, AND, OR), viene determinato se l'istruzione coinvolge registri o memoria.
2. Se l'istruzione coinvolge un registro come primo operando, viene inserita una chiamata alla funzione `handle_clear_reg` prima dell'esecuzione dell'istruzione. Questa chiamata sembra essere responsabile della pulizia dei marcatori di contaminazione associati al registro.
3. Se l'istruzione coinvolge la memoria come primo operando, viene verificato se il secondo operando è un immediato o un registro. Se è un immediato, viene inserita una chiamata alla funzione `handle_clear_mem` per pulire la memoria prima dell'accesso. Se è un registro, viene inserita una chiamata alla funzione `handle_clear_reg` per pulire il registro.
4. Se l'istruzione non coinvolge registri, viene ignorata.

In generale, questo codice sembra essere parte di un sistema per gestire la contaminazione dei dati (taint) durante l'esecuzione del programma, garantendo che determinate operazioni siano eseguite su dati non contaminati.