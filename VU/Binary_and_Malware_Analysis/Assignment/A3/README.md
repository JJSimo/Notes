# Fill the gaps in the framework 
The first thing that I did was to fill some of the missing codes inside the framework.
I started editing the `handle_mov_memtomem` and `handle_mov_regtomem` functions.
In the first one, since we need to propagate the taints, the function should copying the taint values from the source memory to the destination memory.
For this reason I edited the for loop in this way:
`for (unsigned n = 0; n < N; ++n) {`
	`shadowTo[n] = shadowFrom[n];`
`}`
In the second one, for maintaining the integrity of taint information when data is moved from a register to memory, we should copy the taint value from the register `reg+n` to the corresponding byte in the memory shadow:
`for (unsigned n = 0; n < N; ++n) {`
	`shadow[n] = g_regTags[reg+n];` 
`}`

# Clear the taint
Before attempting the step 1, I implemented the code to clear the taint before the arithmetic operations.
The only operand that must be checked here is the first one and for this reason I controlled if it was a register or a memory address and then I passed it to `handle_crear_reg` function and `handle_crear_mem` function (respectively) to clear the taint.
In the register case I passed as arguments the register size and the register number. 
Whereas instead in the memory case I passed the size of the memory and the memory address.
`case XED_ICLASS_ADD:
`case XED_ICLASS_SUB:`
`case XED_ICLASS_SBB:`
`case XED_ICLASS_SHL:`
`case XED_ICLASS_SHR:`
`case XED_ICLASS_ROR:`
`case XED_ICLASS_XOR:`
`case XED_ICLASS_AND:`
`case XED_ICLASS_OR:`
	`if (INS_OperandIsReg(ins, 0)) {`
		`INS_InsertCall(ins, IPOINT_BEFORE,`
			`(AFUNPTR)handle_clear_reg,`
			`IARG_UINT32, getRegSize(INS_OperandReg(ins, 0)),`
			`IARG_UINT32, getTaintReg(INS_OperandReg(ins, 0)),`
			`IARG_END);`
	`} else if (INS_OperandIsMemory(ins, 0)) {`
		`INS_InsertCall(ins, IPOINT_BEFORE,`
			`(AFUNPTR)handle_clear_mem,`
			`IARG_UINT32, INS_OperandWidth(ins, 0)/8,`
			`IARG_MEMORYREAD_EA,`
			`IARG_END);`
`}`

# Direct comparisons
To implement the direct `CMP`  instrumentation I handled a lot of different cases:
- Register-Immediate
- Immediate-Register
- Memory-Immediate
- Immediate-Memory
- Register-Register
- Register-Memory
- Memory-Register

For each of them I created a function to handle the instrumentation. Here I checked if the register/memory/immediate was tainted (so if was `!= 0`) and if so I printed a debug message that contained the comparison.

# Library function comparisons
To understand which functions could perform comparisons I used the command:
`objdump -T VUVianBox | grep "UND"`
The suspicious functions that I decided to check are:
- `memset`
- `memcpy`
- `strcpy`
- `memcmp`
- `strcmp`
- `strncmp`

For `memset`, `memcpy` and `strcpy` I created 3 functions that simply propagate the taint from the source operand to the destination operand.
In `memset`, since the `c` parameter is stored inside `RSI`, I propagate the taint from RSI to the destination.

Instead, for `memcmp`, `strcmp` and `strncmp` I created other 3 functions similar to the one that I wrote for the direct comparison. Therefore, I first checked if the parameters were tainted, and if so I print a debug message with the actual comparison.

# Arithmetic evasion
To implement the third part, I first commented the code that I wrote for clearing the taint.
Then to handle all the arithmetic instructions I managed only the three cases:
- Register-Register
- Memory-Register
- Register-Memory

Here we need to focus only on the right part, so if it is tainted, then we just have to propagate the taint to the left part. Using this logic, I implemented the three functions that handle these cases. 

Having not been able to implement the fourth part, my `input_secret.txt` file contains some non- ascii characters, probably due to not implementing the obfuscation part

# Find the flags
By analyzing the binary with `ltrace`, I found that it uses the `getopt_long()` function in this way:
`getopt_long(1, 0x7ffc892cc438, "i:fuktvapx:h", 0x4153c0, 0)`
`getopt` is a function used to parse arguments passed to a command-line program.
In this case the parameters that the binary accepts are `i`, `f`, `u`, `k`, `t`, `v`, `a`, `p`, `x` and `h`. Trying all of them I realized that `-a` probably equals `-all`, so it allows you to use all the flags.

# Automatize 
To automate the whole process of extracting the identity file, I created a script in bash that compiles the program, runs the binary, redirects the output of the binary into a text file `input_needed_parse.txt` and, finally, calls the python script that generates the correct identity file.

The python script does 3 things mainly:
1) Initializes the `input_secret.txt` file with only `-`
2) Reads the contents of `input_needed_parse.txt`, which contains all debug messages printed by the program and extracts from it the offset where to replace the correct character and the character itself (converted from hexadecimal to character).
3) Replaces the extracted characters


