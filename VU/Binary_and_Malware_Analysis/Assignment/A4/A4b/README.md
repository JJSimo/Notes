# Run my implementation
To run my solution, in each folder, there is a script called `script_final.sh`.
Read the Script paragraph to understand what the other scripts do.

# Data flow Analysis
I started implementing the data flow analysis.
I created a Ghidra script in python to "simulate" the PIN tool behavior to instrument each instructions in all the functions within the array and propagate the taint if needed.

By analyzing some of the functions in Ghidra, I understood that in each function the input value is stored in `RDI` and the output value is contained in `RAX`.
Thus, a washer function is one in which if at the beginning of it `RDI` is tainted, then before return `RAX` is also tainted.
Whereas, in contrast, in a fake washer function `RAX` at the end is not tainted.

In my script I created 2 classes, a Registers class to manage the taint state of registers (at the start I supposed that only `RDI` is tainted), and the Stack class to handle stack operations (`PUSH` and `POP`).
Then, I disassembled each instruction of each function to "instrument" all the possible types of instructions and to propagate the taint where needed.
As I said before, when I "instrumented" each function, only `RDI` is tainted. 
Then for example I checked if the current instruction was a `MOV`, I verified if both the operands were registers and I checked if the source operand was tainted, and if so, I propagated the taint the destination operand as well. In the same way, I implemented also the `XOR` and `ADD` instructions.
For the `PUSH` and `POP` instructions, I pushed and popped the register within my stack and for the `INC` and `SHL` instructions I checked if the operand was a register and it was tainted, and if so I kept the taint to the register.
Then, at the `RET` instruction I saved the function within the washer functions array if `RAX` was tainted or I saved the function inside the fake washer functions array if `RAX` wasn't tainted.
At the end of all functions I thus generated two arrays containing all washer functions and fake washer functions and I also save them in 2 different text files.

## PIN tool
I modified my PIN tool to save in 2 vectors, washers and fake washers, all the functions within the 2 text files generated with my Ghidra script.
Then, to properly propagate and clear the taint, I instrumented each `CALL` and `RET`.

For each `CALL`:

- I checked if the target of the `CALL` was one of the functions inside my washers vector, and if so, I controlled if `RDI` was tainted and then I stored the tainted value inside a global array to keep track of it and use it during the `RET` and I also set a boolean global variable `checkWash` to true.
- On the other hand, I checked if the target of the `CALL` was within my fake washers vector and then I set a boolean global variable `checkFake` to true.

For each `RET`:

- I controlled if the `checkWash` variable was true, meaning that before this `RET` there was a `CALL` for a function among the washer functions, and if so, I propagated the taint by setting `RAX` to the taint value stored in my global array. Finally, I set again `checkWash` to false.
- I handled the fake washer functions with exactly the same logic, but here I cleared the taint, so I set `RAX` to 0.

# CFG Analysis
Having already done the data flow analysis, I had already classified the functions into washers and fake washers.


# Script

# Question
