# Data flow Analysis
I started implementing the data flow analysis.
I created a Ghidra script in python to "simulate" the PIN tool behavior to instrument each instructions in all the functions within the array and propagate the taint if needed.

By analyzing some of the functions in Ghidra, I understood that in each function the input value is stored in `RDI` and the output value is contained in `RAX`.
Thus, a washer function is one in which if at the beginning of it `RDI` is tainted, then before return `RAX` is also tainted.
Whereas, in contrast, in a fake washer function `RAX` at the end is not tainted.

In my script I created 2 classes, a Registers class to manage the taint state of registers (at the start I supposed that only `RDI` is tainted), and the Stack class to handle stack operations (`PUSH` and `POP`).
Then, I disassembled each instruction of each function to "instrument" all the possible types of instructions and to propagate the taint where needed.
As I said before, when I instrumented each function, only RDI is tainted. 
Then for example I checked if the current instruction was a `MOV`, I verified if both the operands were registers and I checked if the source operand was tainted, and if so, I propagated the taint the destination operand as well. In the same way, I implemented also the `XOR` and `ADD` instructions.
For the `PUSH` and `POP` instructions, I pushed and popped the register within my stack and for the `INC` and `SHL` instructions I checked if the operand was a register and it was tainted, and if so I kept the taint to the register.
Then, at the `RET` instruction I saved the function within the washer functions array if `RAX` was tainted or I saved the function inside the fake washer functions array if `RAX` wasn't tainted.
At the end of all functions I thus generated two arrays containing all washer functions and fake washer functions.

## PIN tool





# CFG Analysis

# Script

# Question
