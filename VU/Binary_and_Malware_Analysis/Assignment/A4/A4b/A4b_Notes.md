![[Pasted image 20240516155119.png]]
Devo analizzare un binario in C e determinare se le funzioni in un determinato array sono washer o fake washer.
Una funzione washer è una funzione che pulisce la taint di un registro, e di conseguenza bisogna modificare ciascuna di queste funzioni in modo che non puliscano la taint ma che la propagano correttamente:

Una funzione fake washer è una funzione che deve essere patchata in modo che la taint venga pulita. 

Il mio compito è classificare le funzioni dell'array in washer e fake washer scrivendo un ghidra script in python. 
Una possibile classificazione è usando il dataflow analysis: osservare come i dati fluiscono attraverso la funzione e costruire un rilevamento più affidabile.

Per implementare ciò ho creato questo script, che penso è come se instrumentasse ogni possibile istruzione di ogni funzione e propaga la taint in modo appropriato. (non ci sono altre tipologie di istruzioni in queste funzioni, ho controllato con ghidra.


Since I did not complete the advance obfuscation in assignment 3, even though I did all the points for this assignment, I was unable to generate the `output_secret.txt`.

I take this opportunity to say that I do not think it is fair that people like me should be deducted 0.25 for not completing a single part of an old assignment, even if everything is done correctly for the new one. Each assignment should be its own and should give the same opportunity of points for everyone.



----
So I think that by using them you can identify that:
- the Graph structure has an array of pointers to struct successors.
- each struct successors contains an array of integers representing the successors of each node.
- variations in list length (caused by `realloc`).
- since each node is dynamically allocated, Mempick should be able to track these allocations and how they are linked together
- lists and, potentially, check if they are kept in order (by analyzing the links between nodes)
So, from the Graph Struct these techniques should help to find the nodes and successor lists, dynamic allocations.

On the other hand, for the `search_info` structure, it might help to find:
- the different dynamically allocated arrays (`preorder`, `time`, `parent`, `depth`), tracking how they are allocated and used during the execution of the DFS.

 During the execution of the `dfs` function, MemPick will observe how the values in these arrays are modified, thus providing insight into how the search alters the state of the structure.


