# Dynamic deobfuscation
## Call address obfuscation
By analyzing the binary in Ghidra, I understood that the basic call address obfuscations are structured in this way:
`ADD        RBX,-0x7c430c6`
`CALL       RBX`

`MOV RBX, 0xaddressFunction`
`CALL RBX`

So before the `CALL`, there is an instruction that modifies the register value used for the `CALL` instruction, so it modifies the actual address of the function that is being called.

For this reason, in my PIN tool I checked for every instruction if it's a `CALL` instruction  and I also saved the previous instruction.
Then I checked if the `CALL` operand is a register and also if the second operand of the previous instruction is an immediate, and I sent these arguments to a handler function that prints:
- the address of the instruction in which the `CALL` is made.
- the address of the function being called
- the address of the previous instruction
- the register used for the `CALL`

In my ghidra scripting I parse these values and to deobfuscate each of these calls, I simply patch the `ADD` instruction to a `MOV` `%REGISTER 0xFUNCTION_ADDRESS`
Where:
`%REGISTER` = register used by the CALL instruction.
`0xFUNCTION_ADDRESS` = address of the function that should be called

## Return address obfuscation
The second type of obfuscation modifies the returning address of the functions by adding to them a variable offset.
To solve this part I instrumented every calls and I passed the current instruction address, the target address of the call and the size of the current instruction to a handler function. This function checks if the current instruction is within the binary boundaries and outside the PLT table (to find those values I used some pin APIs inside the ImageLoad and Trace methods).
If the current instruction is inside these values I calculated the 

Per ogni ritorno: 
- prendi l'indirizzo dell'istruzione successiva dallo stack
- controlla se l'indirizzo dell'istruzione successiva Ã¨ uguale all'indirizzo dell'istruzione corrente?
