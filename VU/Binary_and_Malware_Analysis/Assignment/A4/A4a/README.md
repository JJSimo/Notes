# Dynamic deobfuscation
## Call address obfuscation
By analyzing the binary in Ghidra, I understood that the basic call address obfuscations are structured in this way:
`ADD        RBX,-0x7c430c6`
`CALL       RBX`

`MOV RBX, 0xaddressFunction`
`CALL RBX`

Then, before the `CALL`, there is an instruction that modifies the register value used for the `CALL` instruction, so it modifies the actual address of the function that is being called.

For this reason, in my PIN tool I checked for every instruction if it's a `CALL` instruction  and I also saved the previous instruction.
Then I checked if the `CALL` operand is a register and also if the second operand of the previous instruction is an immediate, and I sent these arguments to a handler function that prints:
- the address of the instruction in which the `CALL` is made.
- the address of the function being called
- the address of the previous instruction
- the register used for the `CALL`

- In my ghidra script I parse these values and to deobfuscate each of these calls, I simply patch the `ADD` instruction to a `MOV` `%REGISTER 0xFUNCTION_ADDRESS`
Where:
`%REGISTER` = register used by the CALL instruction.
`0xFUNCTION_ADDRESS` = address of the function that should be called

## Return address obfuscation
The second type of obfuscation modifies the return address of the functions by adding to them a variable offset.
To solve this part I instrumented every `CALL` and I passed the current instruction address, the target address of the call and the size of the current instruction to a handler function. This handler checks if the current instruction is within the binary boundaries and outside the PLT table (to find those values I used the pin APIs inside the `ImageLoad` and `Trace` methods).
If the current instruction is within these values, I calculated the next instruction by adding its size to the current one. Then I added these values inside a stack I created earlier.
After that, I also instrumented each `RET`, saved the actual return address and compared it to the address at the top of my stack that I calculated earlier (thus the saved return address). If the actual return address and the saved return address were not the same, I printed those values so that I could parse them within my ghidra script.

In my ghidra script, to deobfuscate this second obfuscation type, I patched each instruction between the saved return address and the actual return address with `NOP`s, so that when the `CALL` returns, the next instruction that will be executed will be the correct one.


# Question
I think that, in theory, you can't obtain the call graph using static analysis, since with this type of analysis you don't have access to the runtime context (thus to the stack for example).
However, perhaps a possibility exists. For instance, we could identify the “call oracle” and the hash table in the code, and analyze how they are used. This could provide hints about possible call destination addresses.
