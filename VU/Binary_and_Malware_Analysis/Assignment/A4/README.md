# Dynamic deobfuscation
## Call address obfuscation
By analyzing the binary in Ghidra, I understood that the basic call address obfuscations are structured in this way:
`ADD        RBX,-0x7c430c6`
`CALL       RBX`

So before the `CALL`, there is an `ADD` operation and a constant is added to the register the containts the address of the actual function that it's executed.

For this reason, in my PIN tool I checked for every instruction if it's a `CALL` instruction  and I also saved the previous instruction (the `ADD`).
Then I checked if the `CALL` operand is a register and also if the second `ADD` operand is an immediate, and I sent these arguments to a handler function that prints:
- the address of the instruction in which the `CALL` is made.
- the address of the function being called
- the address of the instruction in which the `ADD` (the previous instruction) is made
- the register used for the `CALL`

In my ghidra scripting I parse these values and to deobfuscate each of these calls, I simply patch the `ADD` instruction to a `MOV` `%REGISTER 0xFUNCTION_ADDRESS`
Where:
`%REGISTER` = register used by the CALL instruction.
`0xFUNCTION_ADDRESS` = address of the function that should be called

## Return address obfuscation
