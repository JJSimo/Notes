Per compilare un nuovo file con pin devi modificare il `makefile.rules`
Per esempio 
al posto di qst (x il framework del 3° assign, dove il framework si chiama `inscount0.cpp`):
`TEST_TOOL_ROOTS := inscount0`

Se vogliamo compilare un file che si chiama `test.cpp`:
=> modifichiamo la riga con -->  `TEST_TOOL_ROOTS := test`


Return address obfuscation:
La fz modifica l'indirizzo di ritorno, tipo indirizzo vero + 2 istruzioni

Call address obfuscation:
La fz chiama una fz intermediaria, la fz intermediaria chiama la vera fz

no hardcoded addresses:
trova il base address
dall'indirizzo che hai sottrai il base address e in questo modo -->  trovi il "vero indirizzo"
Nello script in ghidra:
- trova il base address
- aggiungi al base address il vero indirizzo

----
Instrumenta ogni call e printa l'indirizzo contenuto  in `eax` per esempio
![[Pasted image 20240508115135.png]]

istruzione alla quale viene chiamata la funzione
istruzione di dove si trova la funzione in se
https://stackoverflow.com/questions/49862142/intel-pin-how-to-obtain-return-address-of-system-call

NOP = Call address - previous instruction address + 1 - 4


--- 
Analizzando su ghidra il binario ho capito che la tipologia base di obsfucastion è un valore che viene sommato al registro che viene usato per la `CALL`.
Per esempio:
`ADD        RBX,-0x7c430c6`
`CALL       RBX`

Per questo motivo nel metodo per instrumentare, per ogni istruzione controllo se è una chiamata a sistema e salvo anche l'istruzione precedente.
Dopo di che controllo se l'operando dell'istruzione `CALL` è un registro e poi controllo se il secondo operando dell'istruzione `ADD` (quindi dell'istruzione precedente) è un immediate e in tal caso chiamo funzione handler che stampa a video:
- l'indirizzo dell'istruzione in cui viene effettuata la `CALL`
- l'indirizzo dell'istruzione in cui viene effettuata la `ADD` (l'istruzione precedente)
- il registro usato per la `CALL`

Nel mio ghidra scripting parso questi valori 