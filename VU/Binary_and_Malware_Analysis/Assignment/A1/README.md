# System calls
The first thing that I found is that there is only one function that makes the system calls.
Every time that a system call is needed, its integer value is passed inside the `EAX` register and then this single function is called to perform the system call. So to "decrypt" all the system calls I searched what every system call number is associated to which call.

# Anti Debugging
In the binary I found 2 calls to `ptrace`.
Since only one debugger can be attached to a program at any time:
- the first `ptrace` call should return 0 (so that the binary can debug itself and bypass the check
- and consequently the second call should return -1 (because the binary is already being traced, so the correct value that `ptrace` should return is an error).

To patch these 2 calls I inserted, instead of the ptrace calls, the right returning values inside the register used to store the ptrace result. And where necessary I added `NOP` instructions to maintain the same number of bytes used by the original calls to `ptrace`.
So:
first patch: 
- `XOR RBX, RBX`  
 _<span style="color:#00b050"> this is a mistake</span>_ 
	 the returning value is into `RAX`
	 so I should `XOR` `RAX`   
	 but since `RAX` is a positive value and `ptrace` returns `-1` as fails error =>  it works anyway :)
- 2 `NOP`s
second patch: 
- `XOR RAX, RAX`
- `SUB RAX, 0x1` 
- `NOP`
# Basic Anti VM and HW detection 
One of the functions within main is something like an encryption function.  It takes 3 parameters and It utilizes a loop to encrypt bytes in the second one using `XOR` operation with the constant `0x4a` and storing the results inside the first parameter.
By writing a simple program I could decrypt all the strings that I found inside the binary.

One other function in main is a string compare function. I found it twice:
the first strings comparison is with the VU AMSTERDAM string. 
Since the string_compare function returns 0 if the 2 compared strings are equal, I patched the first call to this function with `XOR EAX, EAX` and  three `NOP`s (because I believe that the VU AMSTERDAM comparison is related to the Platform Detection, so the function must return 0).
The second string comparison is with innotek_GmbH and I think that this comparison is one of the Anti VM checks, so I patched the second string_compare call with  `MOV EAX, 1`. 

I suppose that there are other Anti-VM techniques since I also found these strings:
- VMware
- VMW
- QEMU
- Bochs

# Master Key
One of the strings that I found inside the binary is VUNIVERSE_KEY. By searching the references to this string, I found 2 functions.
Within one of them there are 2 important things:
1) the `gentenv` function is called, so it searches for a specific environment string and it retrieves the associated value linked to that string (that we can call `pcVar4`).
2) the value of another variable is calculated based on the evaluation of each individual character of `pcVar4`.
   For each character in the string pointed to by `pcVar4`: checks whether it is different from or equal to a given character

I then thought that all these individual characters used for comparisons, if concatenated, could be the master key used to log in within the binary file.
By invoking the binary with: `VUNIVERSE_KEY="BYJFRXXIQBNQPHPVKNHN" ./VUVianConnector`
I can access to the VUVianConnector.

# Debugging messages
With the same little program that I used to find all the strings in the binary, I also found these debugging messages:
`'\n\n\x1b[0;35mVUVianConnector\x1b[0m (version 1.0.3) - BootLoader\n\n\x1b[0;32mSUCCESS:\x1b[0m\tStage 1 loaded successfully!\n\x1b[0;32mSUCCESS:\x1b[0m\tAll systems checks passed!\n\x1b[0;34mSTATUS:\x1b[0m\t\tLoading stage 2...\n\x1b[0;33mWARNING:\x1b[0m\tIllegal access attempt; logging access attempt of hml371...\n\x1b[0;31mCRITICAL:\x1b[0m\tCannot load stage 2: \x1b[0;31mMASTER KEY DISABLED\x1b[0m\n\x00\xd2\x885\n\n\x1b[0;35mVUVianConnector\x1b[0m (version 1.0.3) - BootLoader\n\n\x1b[0;32mSUCCESS:\x1b[0m\tStage 1 loaded successfully!\n\x1b[0;32mSUCCESS:\x1b[0m\tAll systems checks passed!\n\x1b[0;34mSTATUS:\x1b[0m\t\tLoading stage 2...\n\x1b[0;31mCRITICAL:\x1b[0m\tCannot load stage 2: \x1b[0;31mINVALID HARDWARE DETECTED\x1b[0m\n\x00'`

`\n\n\x1b[0;35mVUVianConnector\x1b[0m (version 1.0.3) - BootLoader\n\n\x1b[0;32mSUCCESS:\x1b[0m\tStage 1 loaded successfully!\n\x1b[0;32mSUCCESS:\x1b[0m\tAll systems checks passed!\n\x1b[0;34mSTATUS:\x1b[0m\t\tLoading stage 2...\n\x1b[0;31mCRITICAL:\x1b[0m\tCannot load stage 2: \x1b[0;31mSYSTEM COMPROMISED\x1b[0m\n\x00\n\n\x1b[0;35mVUVianConnector\x1b[0m (version 1.0.3) - BootLoader\n\n\x1b[0;32mSUCCESS:\x1b[0m\tStage 1 loaded successfully!\n\x1b[0;32mSUCCESS:\x1b[0m\tAll systems checks passed!\n\x1b[0;34mSTATUS:\x1b[0m\t\tLoading stage 2...\x00\n\n\x1b[0;35mVUVianConnector\x1b[0m (version 1.0.3) - BootLoader\n\n\x1b[0;32mSUCCESS:\x1b[0m\tStage 1 loaded successfully!\n\x1b[0;32mSUCCESS:\x1b[0m\tAll systems checks passed!\n\x1b[0;31mCRITICAL:\x1b[0m\tCannot load stage 2: \x1b[0;31mACCESS DENIED\x1b[0m\n\x00J`