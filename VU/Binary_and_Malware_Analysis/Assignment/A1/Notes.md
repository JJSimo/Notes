- C'è solo una funzione che fa le system call![[Pasted image 20240406160633.png]]
- ogni volta che serve usare una system call:
  viene passato dentro `EAX` il code della system call usata
	Es per la prima funzione in main:![[Pasted image 20240406160354.png]]

	Se guardiamo nella  [Linux System Call Table](https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#linux-system-call-table):
	12 corrisponde alla system call `brk`![[Pasted image 20240406160537.png]]


https://reverseengineering.stackexchange.com/questions/31749/how-to-bypass-anti-debugger-ida-pro


## Anti Debugging
c'è una funzione che chiama la system call `ptrace`
`ptrace` -->   può essere usata per testare se stai usando un debugger

Il valore di ritorno di una funzione in assembly x86-64 è settato dentro -->  `RAX`
=>
- Controlliamo dove la funzione sys_ptrace() viene chiamata
  tasto dx sulla fx `sys_ptrace()` > References > Show references to sys_ptrace()![[Pasted image 20240407114934.png]]

- Focalizziamoci prima sulla prima chiamata
	- copiamo l'indirizzo di memoria prima e successivo alla `CALL`
	- apriamo `gdb`
	- settiamo due breakpoint a questi due indirizzi:
		- `b *0x00100dd3`
		- `b *0x00100dd8` 
	- avviamo il programma -->  `run`
	- si bloccherà al primo breakpoint
		- Controlliamo i registri -->  `registers`
		- controlliamo il valore di `RAX`![[Pasted image 20240407120117.png]]
		- continuiamo con il programma con `run`      =>  raggiungiamo il 2 breakpoint
		  =>
		  dopo la chiamata a ptrace
		- controlliamo i registri di nuovo:![[Pasted image 20240407120356.png]]
		  
		- <span style="color:#00b050">Ora RAX è -1</span>

=>
Questi sono i possibili valori di ritorno della funzione `ptrace:`
![[Pasted image 20240407120525.png]]
=>
Dopo la nostra chiamata a funzione il valore settato è -->  <span style="color:#00b050">-1</span> 
=>
Dobbiamo fare in modo che al posto di -1 ci sia -->  <span style="color:#00b050">0</span>

### Patching ptrace return value
Questo è il codice usato per la chiamata della system call `ptrace`:
![[Pasted image 20240407120704.png]]
=>
possiamo notare che:
- il valore di ritorno di ptrace è -->  `RBX`  
- la chiamata in se con `CALL` -->  occupa 5 byte
=>
cosa facciamo:
- <span style="color:#00b050">Dobbiamo settare il valore RBX a 0</span>
  sostituiamo la `CALL` con -->  `XOR RBX, RBX`
  =>
	- tasto dx sulla CALL > <span style="background:#fff88f">Patch Instruction</span> 
- questa istruzione occupa 3 bytes![[Pasted image 20240407121307.png]]
  =>
- Dopo aver inserito questa istruzione dobbiamo inserire 2 `NOP`

- In questo modo i bytes usati saranno sempre gli stessi

### Exporting the patched binary
Ora dobbiamo esportare il nuovo binario per testarlo:
- File > Export Program > Select Original File > Change the name
- set the execute permission and execute it in gdb
- <span style="color:#00b050">ORA IL MESSAGGIO DI ERRORE NON E' PIU' SYSTEM COMPROMISED</span>
  =>
  _<span style="color:#00b050">ABBIAMO BYPASSATO LA TECNICA DI ANTI DEBUGGING</span>_![[Pasted image 20240407122111.png]]

## Anti VM

`MOV EAX, 1` al posto di una delle due CALL to `strings_compare`

## Strings
La funzione FUN_001002ff():
esegue un'operazione di cifratura o decifratura su un buffer di byte.
Prende tre parametri: 
1) un puntatore al buffer di destinazione (param_1)
2) un puntatore al buffer sorgente (param_2)
3) la lunghezza del buffer (param_3)

- Viene eseguita un'perazione di `XOR` tra i byte del buffer sorgente e il valore costante `0x4a`
- il risultato viene memorizzato nel buffer di destinazione
- Il ciclo continua finché non viene incontrato un byte con valore 74 (`0x4a XOR 0x4a`)
- dopo di che la funzione ritorna

=>
Copiando ogni stringa con tasto destro > Copy Special > Byte Strings possiamo copiare i byte della stringa

Usando il programma in python possiamo decifrare le stringhe

```python
def decrypt_bytes(source):
    decrypted = bytearray()
    for byte in source:
        decrypted_byte = byte ^ 0x4a
        decrypted.append(decrypted_byte)
        if decrypted_byte == 0x4a:  # Se incontriamo il byte 0x4a (74), termina la decifrazione
            break
    return decrypted

def main():
    encrypted_bytes = bytes.fromhex("byte stringa")
    decrypted_bytes = decrypt_bytes(encrypted_bytes)
    print("Bytes decifrati:", decrypted_bytes)

if __name__ == "__main__":
    main()
```
