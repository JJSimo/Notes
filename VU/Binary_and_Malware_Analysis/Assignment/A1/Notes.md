- C'è solo una funzione che fa le system call![[Pasted image 20240406160633.png]]
- ogni volta che serve usare una system call:
  viene passato dentro `EAX` il code della system call usata
	Es per la prima funzione in main:![[Pasted image 20240406160354.png]]

	Se guardiamo nella  [Linux System Call Table](https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#linux-system-call-table):
	12 corrisponde alla system call `brk`![[Pasted image 20240406160537.png]]


https://reverseengineering.stackexchange.com/questions/31749/how-to-bypass-anti-debugger-ida-pro


## Anti Debugging 1
c'è una funzione che chiama la system call `ptrace`
`ptrace` -->   può essere usata per testare se stai usando un debugger

Il valore di ritorno di una funzione in assembly x86-64 è settato dentro -->  `RAX`
=>
- Controlliamo dove la funzione sys_ptrace() viene chiamata
  tasto dx sulla fx `sys_ptrace()` > References > Show references to sys_ptrace()![[Pasted image 20240407114934.png]]

- Focalizziamoci prima sulla prima chiamata
	- copiamo l'indirizzo di memoria prima e successivo alla `CALL`
	- apriamo `gdb`
	- settiamo due breakpoint a questi due indirizzi:
		- `b *0x00100dd3`
		- `b *0x00100dd8` 
	- avviamo il programma -->  `run`
	- si bloccherà al primo breakpoint
		- Controlliamo i registri -->  `registers`
		- controlliamo il valore di `RAX`![[Pasted image 20240407120117.png]]
		- continuiamo con il programma con `run`      =>  raggiungiamo il 2 breakpoint
		  =>
		  dopo la chiamata a ptrace
		- controlliamo i registri di nuovo:![[Pasted image 20240407120356.png]]
		  
		- <span style="color:#00b050">Ora RAX è -1</span>

=>
Questi sono i possibili valori di ritorno della funzione `ptrace:`
![[Pasted image 20240407120525.png]]
=>
Dopo la nostra chiamata a funzione il valore settato è -->  <span style="color:#00b050">-1</span> 
=>
Dobbiamo fare in modo che al posto di -1 ci sia -->  <span style="color:#00b050">0</span>

### Patching ptrace return value
Questo è il codice usato per la chiamata della system call `ptrace`:
![[Pasted image 20240407120704.png]]
=>
possiamo notare che:
- il valore di ritorno di ptrace è -->  `RBX`  
- la chiamata in se con `CALL` -->  occupa 5 byte
=>
cosa facciamo:
- <span style="color:#00b050">Dobbiamo settare il valore RBX a 0</span>
  sostituiamo la `CALL` con -->  `XOR RBX, RBX`
  =>
	- tasto dx sulla CALL > <span style="background:#fff88f">Patch Instruction</span> 
- questa istruzione occupa 3 bytes![[Pasted image 20240407121307.png]]
  =>
- Dopo aver inserito questa istruzione dobbiamo inserire 2 `NOP`

- In questo modo i bytes usati saranno sempre gli stessi

### Exporting the patched binary
Ora dobbiamo esportare il nuovo binario per testarlo:
- File > Export Program > Select Original File > Change the name
- set the execute permission and execute it in gdb
- <span style="color:#00b050">ORA IL MESSAGGIO DI ERRORE NON E' PIU' SYSTEM COMPROMISED</span>
  =>
  _<span style="color:#00b050">ABBIAMO BYPASSATO LA TECNICA DI ANTI DEBUGGING</span>_![[Pasted image 20240407122111.png]]

## Anti Debugging 2
Per la seconda chiamata a `ptrace` il discorso è diverso:
se il programma chiama `ptrace` per la seconda volta
=>
è già in fase di tracciatura  =>  <span style="color:#00b050"> il valore che corretto che dovrebbe ritornare ptrace è</span> `-1`
                           (ovvero di errore)
                           
<span style="background:#fff88f"> Come patchare il secondo ptrace:</span>
![[Pasted image 20240408142630.png]]
=>
- Non so perchè ma questa volta il registro in cui è salvato il risultato è `RAX`
- Quello che dobbiamo inserire come valore è `-1`
	- => Settiamo a 0 `RAX`
	- Sottriamo 1 a `RAX`
	  
Così:
![[Pasted image 20240408143358.png]]
## Anti VM and HW detection 

`MOV EAX, 0` al posto della prima CALL to `strings_compare`
`MOV EAX, 1` al posto della seconda CALL to `strings_compare`
indirizzo prima CALL è -->  `00100f33`  
indirizzo seconda CALL -->  `00100f6d`
![[Pasted image 20240408114658.png]]
I understood that:
- the first strings comparison is with the VU AMSTERDAM string. 
- Since the string_compare function returns 0 if the 2 compared strings are equal:
  =>
	-  I patched the first CALL with `XOR EAX, EAX`
	- three `NOP`s 
- and in the same way:
	- I patched the second string_compare CALL with -->  `MOV EAX, 1`

## Strings
La funzione `FUN_001002ff()`:
esegue un'operazione di cifratura o decifratura su un buffer di byte.
Prende tre parametri: 
1) un puntatore al buffer di destinazione (param_1)
2) un puntatore al buffer sorgente (param_2)
3) la lunghezza del buffer (param_3)

- Viene eseguita un'perazione di `XOR` tra i byte del buffer sorgente e il valore costante `0x4a`
- il risultato viene memorizzato nel buffer di destinazione
- Il ciclo continua finché non viene incontrato un byte con valore 74 (`0x4a XOR 0x4a`)
- dopo di che la funzione ritorna

=>
Copiando ogni stringa con tasto destro > Copy Special > Byte Strings possiamo copiare i byte della stringa

Usando il programma in python possiamo decifrare le stringhe

```python
def decrypt_bytes(source):
    decrypted = bytearray()
    for byte in source:
        decrypted_byte = byte ^ 0x4a
        decrypted.append(decrypted_byte)
        if decrypted_byte == 0x4a:  # Se incontriamo il byte 0x4a (74), termina la decifrazione
            break
    return decrypted

def main():
    encrypted_bytes = bytes.fromhex("byte stringa")
    decrypted_bytes = decrypt_bytes(encrypted_bytes)
    print("Bytes decifrati:", decrypted_bytes)

if __name__ == "__main__":
    main()
```

## Authorization Mechanism
Una delle stringhe che ho decryptato è -->  `VUNIVERSE_KEY`
=>
Se cerchiamo le referenze a tale stringa:
troviamo 2 funzioni -->   - `FUN_001014e2`
                     - `FUN_001010ee`

Nella seconda funzione:![[Pasted image 20240409185730.png]]

<span style="background:#fff88f">Ci sono 2 cose importanti:</span>
1)
- viene chiamata la system call `getenv`:
   `getenv`:
	- searches for the environment string pointed to by **name** 
	- returns the associated value to the string
	  
- Il valore ritornato è salvato all'interno 