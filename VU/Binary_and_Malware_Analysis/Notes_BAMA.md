# Course material
[[practicalbinaryanalysis.pdf|Practical Binary Analysis]]

# Intro
## Why bother Binary Analysis
3 reasons:
- <span style="color:#00b050">code improvement</span><span style="color:#00b050">:</span>
	- there are a lot of old binaries that don't have the source code
	- maybe these binaries have to run on -->  new system
	  =>
	  with binary analysis -->  you can understand what they do and how

- <span style="color:#00b050">vulnerabilities:</span>
	- find exploits
	- for pentesting
	  
- <span style="color:#00b050">malware:</span>
	- for analyzing malwares (what they do, how, can we stop them)

## Binary Analysis
### From source to binaries AND BACK
![[Pasted image 20240403105548.png]]
We'll mostly analyze at -->  assembler level

### Disassembler
Interpret executable files and decode their instructions

<span style="background:#fff88f">Problem with disassembler:</span>
- <span style="color:#00b050">Assembly instructions map univocally to a sequence of bytes</span>
- <span style="color:#ff0000">the opposite operation is not trivial  (true)</span>

other problems:
- Practical limitations

#### Practical limitations
##### Overlapping instructions
x86 instructions have -->   <span style="color:#00b050">variable length</span>
=>
- start addresses of instructions -->  are not known in advance
=>
<span style="background:#fff88f">Depending from which byte you start disassembling:</span>
<span style="color:#00b050">you can obtain different instructions</span>

if you start reading the instructions:
- from the first byte =>  you obtain the second line
- from the third byte =>  you obtain the third line
![[Pasted image 20240403110126.png]]

##### Desynchronization
How to distinguish data from code?
sometimes the decompiler -->  interprets junk data for code  (and viceversa)

##### Anti-disassembly tricks
we'll see later
(nowadays malwares try to understand if they are running inside a sandbox or with a debugger)
(to try to stop people from analyzing the binary)

#### Practical approaches
<span style="background:#fff88f">2 approaches:</span>
- <span style="color:#00b050">Linear</span>
	- start at the beginning of code                          (`.text`) section
	- disassemble <span style="color:#00b050">one instruction after another</span>
	- `gdb` uses this approach
	  
- <span style="color:#00b050">Recursive</span>
	- start at the program entry point
	- disassemble one instruction after the other:
	  <span style="color:#00b050">until</span> you find a -->   <span style="color:#00b050">control flow instruction</span>     (es `jmp`)
	- recursively follow the targets of `jmp`
	  
	- PRO:
	  better at interleaving data/code                            (interlacciare)

	- CONS:
	  code coverage   ()

	- `IDA`, `Ghidra` use this approach
	  
### Why is decompilation difficult
- Structure is lost
	- Data types are lost
	- Names and labels are lost
	
- No one-to-one mapping
	- The same code can be compiled into different (equivalent) assembler blocks
	- An assembler block can be the result of different code snippets
![[Pasted image 20240403111403.png]]

### What sort of analysis we do
- <span style="color:#00b050">Static analysis</span>
	- Examine the binary without running it
	- In principle, it could tell us everything the program could do
	  
- <span style="color:#00b050">Dynamic analysis</span>
	- Run the program and observe its behaviour
	- Tells us what the program does in a given environment with a particular input

#### Static Analysis
- <span style="color:#00b050">Program level</span>
	- `strings`
	- `readelf`
	- `ldd`
	- `nm`
	- `file`
	- `cat /proc/<pid>/maps`

- <span style="color:#00b050">Instruction level</span>
	- disassemblers (`IDA Pro`)

##### Limitations
- static analysis is undecidable
- Cost =>  it often doesn’t scale to real world programs

#### Dynamic Analysis
- Run the code in its natural habitat  (as much as possible)
- observe what it is doing

##### Limitations
- You analyze only what you execute
- Anti-debugging/anti-analysis tricks
- Malware needs a sandbox


# The long road to main()
![[Pasted image 20240403112245.png]]

what happen when we run a program?
what is called before the main function

## start
`_start` -->  is where we start
![[Pasted image 20240403112520.png]]
### envp
`__libc_start_main` calls -->   `__libc_init_first`
• Uses magic to set a global variable `__environ`
• This is used when calling main
=>
the `envp` -->  are set through `argv` and `argc`

### lib start main
- Handles some security problems with setuid/setgid programs
- Starts up threading
- Registers the `fini`, and `rtld_fini` (run-time loader) arguments:
  to get run by `at_exit` to run the program's and the loader's cleanup routines
  
-  Calls the init argument
- Calls main with:    (`__libc_csu_init`)
	- the `argc` and `argv` arguments passed to it 
	- the global `__environ` argument as detailed above
	
- Calls exit with the return value of main

#### lib csu init
This is our program's constructor
=>
## Recap
![[Pasted image 20240403113154.png]]

# Anti-analysis techniques
GOAL -->  <span style="color:#00b050">make the analysis as difficult as possible</span>
![[Pasted image 20240404154424.png]]

From a analysis of over 4 MLN malware from 2012:
almost 90% of malware had -->  at least one anti-RE technique                   (RE = Reverse Engineer)

<span style="background:#fff88f">We have 2 main categories for static anti-analysis techniques:</span>
- <span style="color:#00b050">Control flow obfuscation</span>
- <span style="color:#00b050">Data obfuscation</span> 

## Control flow obfuscation
Transformations that make it difficult to -->  <span style="color:#00b050">analyze the flow of control of a program</span> 
=>
- Confuse the analyst about -->  function boundaries
- Confuse the analyst about -->  if statements/loops
- Confuse the analyst about -->  jump targets
=>
<span style="color:#00b050">make harder to analyze the control flow graph</span>

we'll see 3 types of control flow obfuscation:
- <span style="color:#00b050">opaque predicates</span>
- <span style="color:#00b050">control flow flattening</span>
- <span style="color:#00b050">return address patching</span> 

### Opaque predicates
They are:
- <span style="color:#00b050">conditional expressions</span> -->  that evaluate to true or false
- but their <span style="color:#00b050">values</span> are <span style="color:#00b050">known</span> only -->  to the <span style="color:#00b050">obfuscator</span> at obfuscation time
  =>
  <span style="color:#00b050">making it difficult</span> for an attacker to -->  determine their values afterward

Static opaque predicates:
- have a fixed value during runtime
- they are typically constructed using algebraic theorems or quadratic residues. 

<span style="background:#fff88f">Their invariant nature:</span>
makes them -->     <span style="color:#00b050"> easy to detec</span><span style="color:#00b050">t</span> by:
                observing branches that never change at runtime with fuzzing testing
Example:
![[Pasted image 20240404161151.png]]
in this example:
the else will never execute
=>
<span style="color:#00b050">it's useless to analyze the code inside it </span>
=>
<span style="background:#fff88f">with this technique malware developers use these tricks to:</span>
- make <span style="color:#00b050">harder</span> analyzing the code
- <span style="color:#00b050">waste</span> <span style="color:#00b050">time</span> in analyzing useless code
### Control flow flattening
<span style="color:#00b050">Aims to obscure the control flow logic</span> 
=>
- Remove the control flow structure from a function
- Hide the nesting of loops and conditional statements

<span style="background:#fff88f">How:</span>
- Put each block of code as a case inside a <span style="color:#00b050">switch statement</span>
- Wrap the switch inside an <span style="color:#00b050">infinite loop</span>
- The control flow is guided by a <span style="color:#00b050">dispatcher variable</span>
- Each case statement <span style="color:#00b050">assigns the correct value</span> for the next one

Example:
<span style="color:#00b050">Normal control flow:</span>![[Pasted image 20240404161530.png]]

<span style="color:#00b050">Control flow after flattering:</span> 
![[Pasted image 20240404161557.png]]

### return address patching
`ret`:
- pops a value from the stack
- jumps to the place pointed by it

If a function modifies the return value:
disassemblers (es IDA) -->   get confused

Look this example:
![[Pasted image 20240405141439.png]]
- there is a call to -->  `sub_804abec`
- after the call the program should execute -->   `add esp, 14h`

the function `sub_804abec`:
- <span style="color:#ff0000">it modifies the return address</span> 
  =>
  on return from this function to the main code:
  <span style="background:#fff88f">the execution of the code:</span>
	  - don't jump to  `add esp, 14h`   (as expected)
	  - <span style="color:#00b050">jump 5 bytes further</span>
	=>
- `add esp, 14h` will not executed

<span style="background:#fff88f">what can we do to set the normal flow of the program:</span>
<span style="color:#00b050">between</span> the call to the routine and the `add esp, 14h`  instruction:
we can insert -->  <span style="color:#00b050">5</span> `NOP` <span style="color:#00b050">bytes</span> 