# Course material
[[practicalbinaryanalysis.pdf|Practical Binary Analysis]]

# Intro
## Why bother Binary Analysis
3 reasons:
- <span style="color:#00b050">code improvement</span><span style="color:#00b050">:</span>
	- there are a lot of old binaries that don't have the source code
	- maybe these binaries have to run on -->  new system
	  =>
	  with binary analysis -->  you can understand what they do and how

- <span style="color:#00b050">vulnerabilities:</span>
	- find exploits
	- for pentesting
	  
- <span style="color:#00b050">malware:</span>
	- for analyzing malwares (what they do, how, can we stop them)

## Binary Analysis
### From source to binaries AND BACK
![[Pasted image 20240403105548.png|500]]
We'll mostly analyze at -->  assembler level

### Disassembler
Interpret executable files and decode their instructions

<span style="background:#fff88f">Problem with disassembler:</span>
- <span style="color:#00b050">Assembly instructions map univocally to a sequence of bytes</span>
- <span style="color:#ff0000">the opposite operation is not trivial  (true)</span>

other problems:
- Practical limitations

#### Practical limitations
##### Overlapping instructions
x86 instructions have -->   <span style="color:#00b050">variable length</span>
=>
- start addresses of instructions -->  are not known in advance
=>
<span style="background:#fff88f">Depending from which byte you start disassembling:</span>
<span style="color:#00b050">you can obtain different instructions</span>

if you start reading the instructions:
- from the first byte =>  you obtain the second line
- from the third byte =>  you obtain the third line
![[Pasted image 20240403110126.png|500]]

##### Desynchronization
How to distinguish data from code?
sometimes the decompiler -->  interprets junk data for code  (and viceversa)

##### Anti-disassembly tricks
we'll see later
(nowadays malwares try to understand if they are running inside a sandbox or with a debugger)
(to try to stop people from analyzing the binary)

#### Practical approaches
<span style="background:#fff88f">2 approaches:</span>
- <span style="color:#00b050">Linear</span>
	- start at the beginning of code                          (`.text`) section
	- disassemble <span style="color:#00b050">one instruction after another</span>
	- `gdb` uses this approach
	  
- <span style="color:#00b050">Recursive</span>
	- start at the program entry point
	- disassemble one instruction after the other:
	  <span style="color:#00b050">until</span> you find a -->   <span style="color:#00b050">control flow instruction</span>     (es `jmp`)
	- recursively follow the targets of `jmp`
	  
	- PRO:
	  better at interleaving data/code                            (interlacciare)

	- CONS:
	  code coverage   ()

	- `IDA`, `Ghidra` use this approach
	  
### Why is decompilation difficult
- Structure is lost
	- Data types are lost
	- Names and labels are lost
	
- No one-to-one mapping
	- The same code can be compiled into different (equivalent) assembler blocks
	- An assembler block can be the result of different code snippets
![[Pasted image 20240403111403.png]]

### What sort of analysis we do
- <span style="color:#00b050">Static analysis</span>
	- Examine the binary without running it
	- In principle, it could tell us everything the program could do
	  
- <span style="color:#00b050">Dynamic analysis</span>
	- Run the program and observe its behaviour
	- Tells us what the program does in a given environment with a particular input

#### Static Analysis
- <span style="color:#00b050">Program level</span>
	- `strings`
	- `readelf`
	- `ldd`
	- `nm`
	- `file`
	- `cat /proc/<pid>/maps`

- <span style="color:#00b050">Instruction level</span>
	- disassemblers (`IDA Pro`)

##### Limitations
- static analysis is undecidable
- Cost =>  it often doesn’t scale to real world programs

#### Dynamic Analysis
- Run the code in its natural habitat  (as much as possible)
- observe what it is doing

##### Limitations
- You analyze only what you execute
- Anti-debugging/anti-analysis tricks
- Malware needs a sandbox


# The long road to main()
![[Pasted image 20240403112245.png]]

what happen when we run a program?
what is called before the main function

## start
`_start` -->  is where we start
![[Pasted image 20240403112520.png]]
### envp
`__libc_start_main` calls -->   `__libc_init_first`
• Uses magic to set a global variable `__environ`
• This is used when calling main
=>
the `envp` -->  are set through `argv` and `argc`

### lib start main
- Handles some security problems with setuid/setgid programs
- Starts up threading
- Registers the `fini`, and `rtld_fini` (run-time loader) arguments:
  to get run by `at_exit` to run the program's and the loader's cleanup routines
  
-  Calls the init argument
- Calls main with:    (`__libc_csu_init`)
	- the `argc` and `argv` arguments passed to it 
	- the global `__environ` argument as detailed above
	
- Calls exit with the return value of main

#### lib csu init
This is our program's constructor
=>
## Recap
![[Pasted image 20240403113154.png|600]]

# Anti-analysis techniques
GOAL -->  <span style="color:#00b050">make the analysis as difficult as possible</span>
![[Pasted image 20240404154424.png|400]]

From a analysis of over 4 MLN malware from 2012:
almost 90% of malware had -->  at least one anti-RE technique                   (RE = Reverse Engineer)

<span style="background:#fff88f">We have 2 main categories for static anti-analysis techniques:</span>
- <span style="color:#00b050">Control flow obfuscation</span>
- <span style="color:#00b050">Data obfuscation</span> 

## Control flow obfuscation
Transformations that make it difficult to -->  <span style="color:#00b050">analyze the flow of control of a program</span> 
=>
- Confuse the analyst about -->  function boundaries
- Confuse the analyst about -->  if statements/loops
- Confuse the analyst about -->  jump targets
=>
<span style="color:#00b050">make harder to analyze the control flow graph</span>

we'll see 3 types of control flow obfuscation:
- <span style="color:#00b050">opaque predicates</span>
- <span style="color:#00b050">control flow flattening</span>
- <span style="color:#00b050">return address patching</span> 

### Opaque predicates
They are:
- <span style="color:#00b050">conditional expressions</span> -->  that evaluate to true or false
- but their <span style="color:#00b050">values</span> are <span style="color:#00b050">known</span> only -->  to the <span style="color:#00b050">obfuscator</span> at obfuscation time
  =>
  <span style="color:#00b050">making it difficult</span> for an attacker to -->  determine their values afterward

Static opaque predicates:
- have a fixed value during runtime
- they are typically constructed using algebraic theorems or quadratic residues. 

<span style="background:#fff88f">Their invariant nature:</span>
makes them -->     <span style="color:#00b050"> easy to detec</span><span style="color:#00b050">t</span> by:
                observing branches that never change at runtime with fuzzing testing
Example:
![[Pasted image 20240404161151.png|400]]
in this example:
the else will never execute
=>
<span style="color:#00b050">it's useless to analyze the code inside it </span>
=>
<span style="background:#fff88f">with this technique malware developers use these tricks to:</span>
- make <span style="color:#00b050">harder</span> analyzing the code
- <span style="color:#00b050">waste</span> <span style="color:#00b050">time</span> in analyzing useless code
### Control flow flattening
<span style="color:#00b050">Aims to obscure the control flow logic</span> 
=>
- Remove the control flow structure from a function
- Hide the nesting of loops and conditional statements

<span style="background:#fff88f">How:</span>
- Put each block of code as a case inside a <span style="color:#00b050">switch statement</span>
- Wrap the switch inside an <span style="color:#00b050">infinite loop</span>
- The control flow is guided by a <span style="color:#00b050">dispatcher variable</span>
- Each case statement <span style="color:#00b050">assigns the correct value</span> for the next one

Example:
<span style="color:#00b050">Normal control flow:</span>![[Pasted image 20240404161530.png|500]]

<span style="color:#00b050">Control flow after flattering:</span> 
![[Pasted image 20240404161557.png|500]]

### return address patching
`ret`:
- pops a value from the stack
- jumps to the place pointed by it

If a function modifies the return value:
disassemblers (es IDA) -->   get confused

Look this example:
![[Pasted image 20240405141439.png]]
- there is a call to -->  `sub_804abec`
- after the call the program should execute -->   `add esp, 14h`

the function `sub_804abec`:
- <span style="color:#ff0000">it modifies the return address</span> 
  =>
  on return from this function to the main code:
  <span style="background:#fff88f">the execution of the code:</span>
	  - don't jump to  `add esp, 14h`   (as expected)
	  - <span style="color:#00b050">jump 5 bytes further</span>
	=>
- `add esp, 14h` will not executed

<span style="background:#fff88f">what can we do to set the normal flow of the program:</span>
<span style="color:#00b050">between</span> the call to the routine and the `add esp, 14h`  instruction:
we can insert -->  <span style="color:#00b050">5</span> `NOP` <span style="color:#00b050">bytes</span> 

when we insert those 5 bytes:
we see new instructions that IDA disassembled 
![[Pasted image 20240405142911.png]]
=>
<span style="background:#fff88f">we can see that actually:</span>
- the function doesn't return
- it keeps going 
=>
previously we saw -->  a <span style="color:#00b050">wrong sequence of instructions </span>
                     (due too the return address patching obsfuscation)
## Data obfuscation
<span style="background:#fff88f">Convert a variable V to a representation:</span>
- that is<span style="color:#00b050"> hard for an analyst to understand</span>
- or that he<span style="color:#00b050"> does not expect</span>
- 
### Hide strings
How can we hide a string:
- `xor` with a known constant value
- convert to a function that computes its value at runtime

### variable splitting
<span style="color:#00b050">Split x into x1 and x2:</span>
- store `x1` and `x2` -->  instead of `x`
- perform operations on x1 and x2 only whenever possible,
  =>
  _<span style="color:#00b050">don’t compute the real value</span>_

example:
![[Pasted image 20240405143624.png|600]]

but:
<span style="background:#fff88f">There are situations when:</span>
- we <span style="color:#00b050">may be forced to compute the actual value of x</span>  
  => 
  the operations on `x1` and `x2` performed individually are not sufficient

<span style="background:#fff88f">example:</span>
<span style="color:#00b050">system calls</span> 

# Anti-dynamic analysis techniques
## Intro Dynamic analysis
run the malware inside a debugger

<span style="background:#fff88f">what can we monitor:</span>
1) <span style="color:#00b050">Persistent changes to OS, network traffic</span>
   example
   - file written/deleted
   - data exchanged over the network

2) <span style="color:#00b050">Interactions between malware and environment (OS)</span>
3) <span style="color:#00b050">Details of the malware execution</span>
   =>
   - how the program process certain inputs
   - how are outputs produced
   - which checks are done

4) <span style="color:#00b050">Details of the malware execution while maintaining good fidelity </span> 

## Evasion 
Malware authors are not sleeping:
- They know about sandboxes too
- Since their code is executed => they implement many options

<span style="background:#fff88f">Evasion example:</span>
Develop code that:
- exhibits <span style="color:#00b050">no malicious behaviour in sandbox</span>
- but <span style="color:#00b050">infects the intended target</span> 

<span style="background:#fff88f">3 main anti-dynamic analysis techniques:</span>
- <span style="color:#00b050">Anti-debugging techniques</span>
- <span style="color:#00b050">Anti-VM techniques</span>
- <span style="color:#00b050">Anti-monitoring techniques</span> 

## Anti-debugging techniques
From the same analysis from the 2012:
70% of the malware analyzed used a `IsDebuggerPresent()` API 
that <span style="color:#00b050">returns TRUE if debugger is present</span>

=>
if true =>  close the program

Other techniques mostly used:
- checks flags related to -->  heap debugging
- and set by the Windows debugger (WinDbg) by default

### Software breakpoint detection
`int 0x3:`
- Stop execution of a debugged process and pass control to debugger
- Debugger overwrites original instruction with the `int 0x3` instruction (opcode: `0xcc`)
  (the original one is saved and executed at the right moment)
=>
<span style="color:#00b050">with this value you can set a breakpoint</span>

=>
malware developers can:
- check for int `0x3` instructions
- if so =>  <span style="color:#00b050">close the program or do something else</span>

### Self debugging
Only one debugger can be attached to a program at any time
=>
Detection: 
make the program try to debug itself.
- if the call fails =>  another debugger is already attached to that process
  
By using the `ptrace` system call you can check this:
![[Pasted image 20240410104221.png|600]]
### Exception traps
A program can intentionally call the `int 0x3` instruction
<span style="background:#fff88f">Detection:</span>
if a debugger is not attached =>  <span style="color:#00b050">the program will raise an exception</span> 
=>
you can check for it
![[Pasted image 20240405145918.png|500]]

### Self debugging
<span style="color:#00b050">Only one debugger</span> can be attached to a program at any time
=>
<span style="background:#fff88f">Detection: </span>
- <span style="color:#00b050">make the program try to debug itself</span>
- if the call fails =>  <span style="color:#00b050">another debugger is already attached to that process</span> 
  =>
  quit or do something else

### Time-based detection
If a process is executed in a <span style="color:#00b050">single-step mode</span> =>  <span style="color:#00b050">it is extremely slow</span>
=>
<span style="background:#fff88f">Detection:</span> 
almost any timing mechanism -->  can be used to detect the anomalously slow execution

### What can we do
- Reduce the debugger visibility
	- Mostly related to Windows data structures
	
- Intercept certain API functions and return fake results
- Single-step through the problematic part and manually disable the anti-debugging checks

## Anti-VM techniques
Malware analysis often uses:
<span style="color:#00b050">VMs to run malware samples</span> 

=>
an increasing fraction of malware -->  “refuses” to run inside virtual environments

### Look for VM-specific artifacts
<span style="background:#fff88f">When a malware runs in a VM:</span>
- there are over 300 references to “VMware” in the Windows Registry
- When VMTools are running, there are three processes in memory 
  (`VMwareService.exe`, `VMwareTray.exe`, `VMwareUser.exe`)
=>
what malware dev can do:
<span style="color:#00b050">look for certain</span> names/strings/processes/configurations -->  <span style="color:#00b050">that are typical of a VM</span> 

<span style="background:#fff88f">Thwarting: </span>
this method can be easily fooled
<span style="color:#00b050">Rootkit-like techniques</span> -->  tweak the OS to hide artifacts from users

### Look for VM-specific virtual hardware
<span style="color:#00b050">VMs introduce virtualized hardware</span>:    (Network card, USB controller)
and:
some of these have <span style="color:#00b050">distinct fingerprints</span> -->   MAC address of NICs, USB controller type
=>
<span style="background:#fff88f">Detection:</span>
<span style="color:#00b050">check for tell-tales of a specific VM</span>

<span style="background:#fff88f">Thwarting: </span>
easily fooled with -->  <span style="color:#00b050">rootkit-like techinques</span> 

### Look for VM-specific processor instructions
<span style="background:#fff88f">Detection: </span>
look for differently -->  <span style="color:#00b050">emulated instructions/behaviour</span> 

why:
- Illegal opcodes supported by the VM (es, to communicate with the host machine)
- Emulated instructions can have different undocumented behaviour
- Many instructions have undocumented side effects that are not present (or they differ) 
  in the emulated CPUs

example:
- VMware needs a <span style="color:#00b050">communication channel between guest and host</span>
- To accomplish it -->  it modifies the functionality of the `IN` instruction![[Pasted image 20240405151917.png]]

## Avoid monitoring
- Open window and wait for user to click    (Or click multiple times)
- Only do bad things after system reboots
- Only run before/after specific dates
- Code execution after initial call to `NtTerminateProcess`

### Sleep
Sleep for a while:
- Analysis time has time-outs
- Typically, a few minutes will do

Anti-sleep-acceleration:
- Some sandboxes skip long sleeps
- but malware authors have figured that out

### Gaus Malware
Gauss Malware has a payload:
that only works on a very specific (unknown) installation:
- It uses the <span style="color:#00b050">environment details</span> -->  as key to decrypt the actual payload

### What can we do about evasion
<span style="color:#00b050">it depends on the anti-analysis technique</span>

<span style="background:#fff88f">with a One key evasion technique:</span>
- it relies on checking for specific values in the environment
  =>
  - We can randomize these values    (if we know about them)
  - We can detect and bypass the triggers automatically

<span style="background:#fff88f">other idea:</span>
- Explore multiple execution paths of the program being analyzed 
	- Exploration is driven by monitoring how program uses certain inputs
	- System should provide info under which circumstances a certain action is triggered


# Packers
<span style="background:#fff88f">packers:</span>
- takes a binary P
- constructs new program that contains:
	- unpacker/executable part
	- <span style="color:#00b050">packed version of P</span>
=>
<span style="background:#fff88f">the loader:</span>
- load the new binary
- the unpacker -->  <span style="color:#00b050">unpacks and load the original program</span> 

## Binary format
- <span style="color:#00b050">Portable Executable (PE)</span> -->  windows
- <span style="color:#00b050">Executable and Linkable Format (ELF)</span> -->  linux
- <span style="color:#00b050">Mach Object file format (Mach-O)</span> -->  Mach

## What the format defines
It defines:
- what the file looks like on disk
- how it should be put together in memory

It contains:
![[Pasted image 20240410172258.png|300]]

When the binary is executed:
![[Pasted image 20240410172432.png|500]]

we'll focus on ELF

## ELF files
have a a dual nature:
they present -->  <span style="color:#00b050">2 possible views to the user</span>
![[Pasted image 20240410173020.png|400]]

The first view -->  it's useful for static linkers
The other view -->  it's useful for system loaders

Both tables -->  are store inside the ELF binary
![[Pasted image 20240411092410.png|250]]

First thing we find in ELF binary:
- <span style="color:#00b050">ELF header</span> -->  [[Notes_ETH#Bypass Check Server-Side (Magic Bytes)|magic bytes]] (always the same bytes that represent the string ELF in this case)
- <span style="color:#00b050">Program header table:</span>
	- divide the data in segments
	- provide an easy mapping from data to memory
	  
- <span style="color:#00b050">Section header table</span>
	- define sections
	- useful bc it's divide logically the content inside the binary

### ELF in deep
#### ELF Header
![[Pasted image 20240411092941.png|400]]
Can be obtain with -->  `readelf -a /path/to/binary`

#### Program header table
Is an <span style="color:#00b050">array of structures:</span>
- where each element -->  <span style="color:#00b050">provides metadata for a particular segment</span>
 => for each element we have this type of <span style="color:#00b050">fields</span>
![[Pasted image 20240411093503.png|400]]

#### Section header table
Array of structures:
- where each element -->  <span style="color:#00b050">provides metadata info for a particular section in the file</span>
These are the fields:
![[Pasted image 20240411093730.png|400]]

