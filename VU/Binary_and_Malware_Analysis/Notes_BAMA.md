# Course material
[[practicalbinaryanalysis.pdf|Practical Binary Analysis]]

# Intro
## Why bother Binary Analysis
3 reasons:
- <span style="color:#00b050">code improvement</span><span style="color:#00b050">:</span>
	- there are a lot of old binaries that don't have the source code
	- maybe these binaries have to run on -->  new system
	  =>
	  with binary analysis -->  you can understand what they do and how

- <span style="color:#00b050">vulnerabilities:</span>
	- find exploits
	- for pentesting
	  
- <span style="color:#00b050">malware:</span>
	- for analyzing malwares (what they do, how, can we stop them)

## Binary Analysis
### From source to binaries AND BACK
![[Pasted image 20240403105548.png]]
We'll mostly analyze at -->  assembler level

### Disassembler
Interpret executable files and decode their instructions

<span style="background:#fff88f">Problem with disassembler:</span>
- <span style="color:#00b050">Assembly instructions map univocally to a sequence of bytes</span>
- <span style="color:#ff0000">the opposite operation is not trivial  (true)</span>

other problems:
- Practical limitations

#### Practical limitations
##### Overlapping instructions
x86 instructions have -->   <span style="color:#00b050">variable length</span>
=>
- start addresses of instructions -->  are not known in advance
=>
<span style="background:#fff88f">Depending from which byte you start disassembling:</span>
<span style="color:#00b050">you can obtain different instructions</span>

if you start reading the instructions:
- from the first byte =>  you obtain the second line
- from the third byte =>  you obtain the third line
![[Pasted image 20240403110126.png]]

##### Desynchronization
How to distinguish data from code?
sometimes the decompiler -->  interprets junk data for code  (and viceversa)

##### Anti-disassembly tricks
we'll see later
(nowadays malwares try to understand if they are running inside a sandbox or with a debugger)
(to try to stop people from analyzing the binary)

#### Practical approaches
<span style="background:#fff88f">2 approaches:</span>
- <span style="color:#00b050">Linear</span>
	- start at the beginning of code                          (`.text`) section
	- disassemble <span style="color:#00b050">one instruction after another</span>
	- `gdb` uses this approach
	  
- <span style="color:#00b050">Recursive</span>
	- start at the program entry point
	- disassemble one instruction after the other:
	  <span style="color:#00b050">until</span> you find a -->   <span style="color:#00b050">control flow instruction</span>     (es `jmp`)
	- recursively follow the targets of `jmp`
	  
	- PRO:
	  better at interleaving data/code                            (interlacciare)

	- CONS:
	  code coverage   ()

	- `IDA`, `Ghidra` use this approach
  
