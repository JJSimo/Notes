# Course material
[[practicalbinaryanalysis.pdf|Practical Binary Analysis]]

# Intro
## Why bother Binary Analysis
3 reasons:
- <span style="color:#00b050">code improvement</span><span style="color:#00b050">:</span>
	- there are a lot of old binaries that don't have the source code
	- maybe these binaries have to run on -->  new system
	  =>
	  with binary analysis -->  you can understand what they do and how

- <span style="color:#00b050">vulnerabilities:</span>
	- find exploits
	- for pentesting
	  
- <span style="color:#00b050">malware:</span>
	- for analyzing malwares (what they do, how, can we stop them)

## Binary Analysis
### From source to binaries AND BACK
![[Pasted image 20240403105548.png]]
We'll mostly analyze at -->  assembler level

### Disassembler
Interpret executable files and decode their instructions

<span style="background:#fff88f">Problem with disassembler:</span>
- <span style="color:#00b050">Assembly instructions map univocally to a sequence of bytes</span>
- <span style="color:#ff0000">the opposite operation is not trivial  (true)</span>

other problems:
- Practical limitations

#### Practical limitations
##### Overlapping instructions
x86 instructions have -->   <span style="color:#00b050">variable length</span>
=>
- start addresses of instructions -->  are not known in advance
=>
<span style="background:#fff88f">Depending from which byte you start disassembling:</span>
<span style="color:#00b050">you can obtain different instructions</span>

if you start reading the instructions:
- from the first byte =>  you obtain the second line
- from the third byte =>  you obtain the third line
![[Pasted image 20240403110126.png]]

##### Desynchronization
How to distinguish data from code?
sometimes the decompiler -->  interprets junk data for code  (and viceversa)

##### Anti-disassembly tricks
we'll see later
(nowadays malwares try to understand if they are running inside a sandbox or with a debugger)
(to try to stop people from analyzing the binary)

#### Practical approaches
<span style="background:#fff88f">2 approaches:</span>
- <span style="color:#00b050">Linear</span>
	- start at the beginning of code                          (`.text`) section
	- disassemble <span style="color:#00b050">one instruction after another</span>
	- `gdb` uses this approach
	  
- <span style="color:#00b050">Recursive</span>
	- start at the program entry point
	- disassemble one instruction after the other:
	  <span style="color:#00b050">until</span> you find a -->   <span style="color:#00b050">control flow instruction</span>     (es `jmp`)
	- recursively follow the targets of `jmp`
	  
	- PRO:
	  better at interleaving data/code                            (interlacciare)

	- CONS:
	  code coverage   ()

	- `IDA`, `Ghidra` use this approach
	  
### Why is decompilation difficult
- Structure is lost
	- Data types are lost
	- Names and labels are lost
	
- No one-to-one mapping
	- The same code can be compiled into different (equivalent) assembler blocks
	- An assembler block can be the result of different code snippets
![[Pasted image 20240403111403.png]]

### What sort of analysis we do
- <span style="color:#00b050">Static analysis</span>
	- Examine the binary without running it
	- In principle, it could tell us everything the program could do
	  
- <span style="color:#00b050">Dynamic analysis</span>
	- Run the program and observe its behaviour
	- Tells us what the program does in a given environment with a particular input

#### Static Analysis
- <span style="color:#00b050">Program level</span>
	- `strings`
	- `readelf`
	- `ldd`
	- `nm`
	- `file`
	- `cat /proc/<pid>/maps`

- <span style="color:#00b050">Instruction level</span>
	- disassemblers (`IDA Pro`)

##### Limitations
- static analysis is undecidable
- Cost =>  it often doesn’t scale to real world programs

#### Dynamic Analysis
- Run the code in its natural habitat  (as much as possible)
- observe what it is doing

##### Limitations
- You analyze only what you execute
- Anti-debugging/anti-analysis tricks
- Malware needs a sandbox


# The long road to main()
![[Pasted image 20240403112245.png]]

what happen when we run a program?
what is called before the main function

## start
`_start` -->  is where we start
![[Pasted image 20240403112520.png]]
### envp
`__libc_start_main` calls -->   `__libc_init_first`
• Uses magic to set a global variable `__environ`
• This is used when calling main
=>
the `envp` -->  are set through `argv` and `argc`

### lib start main
- Handles some security problems with setuid/setgid programs
- Starts up threading
- Registers the `fini`, and `rtld_fini` (run-time loader) arguments:
  to get run by `at_exit` to run the program's and the loader's cleanup routines
  
-  Calls the init argument
- Calls main with:    (`__libc_csu_init`)
	- the `argc` and `argv` arguments passed to it 
	- the global `__environ` argument as detailed above
	
- Calls exit with the return value of main

#### lib csu init
This is our program's constructor
=>
## Recap
![[Pasted image 20240403113154.png]]

